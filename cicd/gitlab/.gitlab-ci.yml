stages:
  - deploy

variables:
  PROJECT_ROOT: "$CI_PROJECT_DIR"
  APP_NAME: devops-app
  NAMESPACE: devops-app
  IMAGE_NAME: devops-app
  IMAGE_TAG: latest

deploy_minikube:
  stage: deploy
  tags:
    - self-hosted
    - minikube
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'

  script:
    - echo "ğŸš€ Production CI/CD (Minikube) â€“ GitLab"

    # Tool versions (same as GHA)
    - docker --version
    - kubectl version --client
    - minikube version
    - node --version || true

    # Checkout already done by GitLab
    - echo "ğŸ“¦ Installing Node.js dependencies"
    - cd app
    - npm install
    - cd ..

    # Ensure Minikube is running
    - |
      if [[ "$(minikube status --format='{{.Host}}')" != "Running" ]]; then
        echo "ğŸ”§ Starting Minikube..."
        minikube start --driver=docker
        minikube addons enable ingress
      fi

    # Build Docker image INSIDE Minikube
    - echo "ğŸ³ Building Docker image inside Minikube"
    - eval "$(minikube docker-env)"
    - docker build -t "$IMAGE_NAME:$IMAGE_TAG" ./app

    # Deploy application (Kustomize)
    - echo "ğŸ“¦ Deploying application via Kustomize"
    - kubectl kustomize kubernetes/overlays/local | kubectl apply -f -

    # Deploy Monitoring Stack
    - echo "ğŸ“Š Deploying Monitoring Stack"

    - export BASE_MONITORING_PATH="$PROJECT_ROOT/kubernetes/base/monitoring"
    - export PROM_CONFIG="$PROJECT_ROOT/monitoring/prometheus/prometheus.yml"
    - export PROM_ALERTS="$PROJECT_ROOT/monitoring/prometheus/alerts.yml"

    # Namespace
    - |
      kubectl apply -f - <<EOF
      apiVersion: v1
      kind: Namespace
      metadata:
        name: monitoring
      EOF

    # Grafana secret (same logic as GHA)
    - |
      : "${GRAFANA_ADMIN_PASSWORD:=admin123}"
      kubectl create secret generic grafana-secrets \
        --from-literal=admin-password="$GRAFANA_ADMIN_PASSWORD" \
        -n monitoring \
        --dry-run=client -o yaml | kubectl apply -f -

    # Dashboards
    - kubectl apply -f "$BASE_MONITORING_PATH/dashboard-configmap.yaml"

    # Prometheus config
    - |
      kubectl create configmap prometheus-config \
        --from-file=prometheus.yml="$PROM_CONFIG" \
        --from-file=alerts.yml="$PROM_ALERTS" \
        -n monitoring \
        --dry-run=client -o yaml | kubectl apply -f -

    # Grafana datasource
    - |
      kubectl create configmap grafana-datasource \
        --from-literal=datasource.yaml="apiVersion: 1
      datasources:
        - name: Prometheus
          type: prometheus
          access: proxy
          url: http://prometheus.monitoring.svc.cluster.local:9090
          isDefault: true" \
        -n monitoring \
        --dry-run=client -o yaml | kubectl apply -f -

    # Dummy dashboards (avoid crashloops)
    - |
      kubectl create configmap grafana-dashboard \
        --from-literal=dummy=empty \
        -n monitoring \
        --dry-run=client -o yaml | kubectl apply -f -

    - |
      kubectl create configmap grafana-dashboard-config \
        --from-literal=dummy=empty \
        -n monitoring \
        --dry-run=client -o yaml | kubectl apply -f -

    # Deploy workloads
    - kubectl apply -f "$BASE_MONITORING_PATH/prometheus.yaml"
    - kubectl apply -f "$BASE_MONITORING_PATH/grafana.yaml"

    # Restart to pick up configs
    - kubectl rollout restart deployment/prometheus -n monitoring
    - kubectl rollout restart deployment/grafana -n monitoring

    # Expose Monitoring (NodePort)
    - |
      kubectl apply -f - <<EOF
      apiVersion: v1
      kind: Service
      metadata:
        name: prometheus
        namespace: monitoring
      spec:
        selector:
          app: prometheus
        ports:
          - port: 9090
            targetPort: 9090
        type: NodePort
      ---
      apiVersion: v1
      kind: Service
      metadata:
        name: grafana
        namespace: monitoring
      spec:
        selector:
          app: grafana
        ports:
          - port: 3000
            targetPort: 3000
        type: NodePort
      EOF

    # Wait for rollouts
    - kubectl rollout status deployment/prometheus -n monitoring --timeout=300s
    - |
      until kubectl get pods -n monitoring -l app=grafana --no-headers | grep Running; do
        echo "â³ Waiting for Grafana pod..."
        sleep 5
      done
    - kubectl rollout status deployment/grafana -n monitoring --timeout=300s

    # Output URLs (CI-safe)
    - |
      echo "ğŸ“Š Resolving service URLs..."
      MINIKUBE_IP=$(minikube ip)

      APP_PORT=$(kubectl get svc devops-app-service -n devops-app \
        -o jsonpath='{.spec.ports[0].nodePort}')

      PROM_PORT=$(kubectl get svc prometheus -n monitoring \
        -o jsonpath='{.spec.ports[0].nodePort}')

      GRAF_PORT=$(kubectl get svc grafana -n monitoring \
        -o jsonpath='{.spec.ports[0].nodePort}')

      echo ""
      echo "## ğŸš€ Deployment URLs"
      echo "- App: http://$MINIKUBE_IP:$APP_PORT"
      echo "- Prometheus: http://$MINIKUBE_IP:$PROM_PORT"
      echo "- Grafana: http://$MINIKUBE_IP:$GRAF_PORT"
