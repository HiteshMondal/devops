# ============================================================================
# GitLab CI/CD Pipeline for DevOps Project
# ============================================================================
# Configure variables in: Project Settings â†’ CI/CD â†’ Variables
# Required Variables: See dotenv_example for complete list
# ============================================================================

variables:
  # Git Configuration
  GIT_STRATEGY: clone
  GIT_DEPTH: "1"
  
  # Docker Configuration
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  
  # Project defaults (can be overridden in CI/CD variables)
  APP_NAME: ${APP_NAME:-devops-app}
  NAMESPACE: ${NAMESPACE:-devops-app}
  APP_PORT: ${APP_PORT:-3000}
  REPLICAS: ${REPLICAS:-2}
  MIN_REPLICAS: ${MIN_REPLICAS:-2}
  MAX_REPLICAS: ${MAX_REPLICAS:-10}
  CPU_TARGET_UTILIZATION: ${CPU_TARGET_UTILIZATION:-70}
  MEMORY_TARGET_UTILIZATION: ${MEMORY_TARGET_UTILIZATION:-80}
  
  # Image Configuration
  DOCKER_IMAGE_TAG: ${DOCKER_IMAGE_TAG:-latest}
  IMAGE_TAG: ${IMAGE_TAG:-latest}
  
  # Ingress Configuration
  INGRESS_ENABLED: ${INGRESS_ENABLED:-true}
  INGRESS_HOST: ${INGRESS_HOST:-devops-app.local}
  INGRESS_CLASS: ${INGRESS_CLASS:-nginx}
  TLS_ENABLED: ${TLS_ENABLED:-false}
  TLS_SECRET_NAME: ${TLS_SECRET_NAME:-devops-app-tls}
  
  # Monitoring Configuration
  PROMETHEUS_ENABLED: ${PROMETHEUS_ENABLED:-true}
  PROMETHEUS_NAMESPACE: ${PROMETHEUS_NAMESPACE:-monitoring}
  PROMETHEUS_RETENTION: ${PROMETHEUS_RETENTION:-15d}
  PROMETHEUS_STORAGE_SIZE: ${PROMETHEUS_STORAGE_SIZE:-10Gi}
  PROMETHEUS_SCRAPE_INTERVAL: ${PROMETHEUS_SCRAPE_INTERVAL:-15s}
  PROMETHEUS_SCRAPE_TIMEOUT: ${PROMETHEUS_SCRAPE_TIMEOUT:-10s}
  
  GRAFANA_ENABLED: ${GRAFANA_ENABLED:-true}
  GRAFANA_ADMIN_USER: ${GRAFANA_ADMIN_USER:-admin}
  GRAFANA_PORT: ${GRAFANA_PORT:-3000}
  GRAFANA_STORAGE_SIZE: ${GRAFANA_STORAGE_SIZE:-5Gi}
  
  # Alerting Configuration
  ALERT_EMAIL_ENABLED: ${ALERT_EMAIL_ENABLED:-false}
  SMTP_HOST: ${SMTP_HOST:-smtp.gmail.com}
  SMTP_PORT: ${SMTP_PORT:-587}
  
  # Resource Limits
  APP_CPU_REQUEST: ${APP_CPU_REQUEST:-100m}
  APP_CPU_LIMIT: ${APP_CPU_LIMIT:-500m}
  APP_MEMORY_REQUEST: ${APP_MEMORY_REQUEST:-128Mi}
  APP_MEMORY_LIMIT: ${APP_MEMORY_LIMIT:-512Mi}
  
  PROMETHEUS_CPU_REQUEST: ${PROMETHEUS_CPU_REQUEST:-500m}
  PROMETHEUS_CPU_LIMIT: ${PROMETHEUS_CPU_LIMIT:-2000m}
  PROMETHEUS_MEMORY_REQUEST: ${PROMETHEUS_MEMORY_REQUEST:-1Gi}
  PROMETHEUS_MEMORY_LIMIT: ${PROMETHEUS_MEMORY_LIMIT:-4Gi}
  
  GRAFANA_CPU_REQUEST: ${GRAFANA_CPU_REQUEST:-100m}
  GRAFANA_CPU_LIMIT: ${GRAFANA_CPU_LIMIT:-500m}
  GRAFANA_MEMORY_REQUEST: ${GRAFANA_MEMORY_REQUEST:-256Mi}
  GRAFANA_MEMORY_LIMIT: ${GRAFANA_MEMORY_LIMIT:-1Gi}
  
  # AWS Configuration
  AWS_REGION: ${AWS_REGION:-us-east-1}
  
  # Deployment Configuration
  BUILD_PUSH: ${BUILD_PUSH:-true}
  CI: "true"
  DRY_RUN: ${DRY_RUN:-false}

# VALIDATION STAGE
validate:variables:
  stage: validate
  image: debian:11
  script: |
      #!/bin/bash
      echo "============================================================================"
      echo "Validating Required CI/CD Variables"
      echo "============================================================================"
      
      REQUIRED_VARS=(
        "APP_NAME"
        "NAMESPACE"
        "DOCKERHUB_USERNAME"
        "DOCKER_IMAGE_TAG"
        "APP_PORT"
        "REPLICAS"
        "DEPLOY_TARGET"
      )
      
      MISSING_VARS=()
      
      for var in "${REQUIRED_VARS[@]}"; do
        if [ -z "${!var}" ]; then
          MISSING_VARS+=("$var")
        fi
      done
      
      if [ ${#MISSING_VARS[@]} -gt 0 ]; then
        echo "âŒ Missing required variables:"
        for var in "${MISSING_VARS[@]}"; do
          echo "   - $var"
        done
        exit 1
      else
        echo "âœ… All required variables are present"
      fi

  rules:
    - if: '$CI_COMMIT_BRANCH || $CI_COMMIT_TAG'

validate:tools:
  stage: validate
  image: debian:11
  script:
    - |
      echo "============================================================================"
      echo "Checking Tool Versions"
      echo "============================================================================"
      docker --version || true
      kubectl version --client || true
      git --version || true
      echo ""
      echo "âœ… All required tools are available"
  rules:
    - if: '$CI_COMMIT_BRANCH || $CI_COMMIT_TAG'

# BUILD STAGE
build-docker-image:
  stage: build
  image: docker:24
  services:
    - docker:24-dind
  variables:
    DOCKER_TLS_CERTDIR: "/certs"
  script: |
    echo "============================================================================"
    echo "Building and Pushing Docker Image"
    echo "============================================================================"
    export PROJECT_ROOT=$CI_PROJECT_DIR
    source "$CI_PROJECT_DIR/app/build_and_push_image.sh"
    build_and_push_image
    echo ""
    echo "âœ… Docker image built and pushed successfully"
    echo "   Image: $DOCKERHUB_USERNAME/$APP_NAME:$DOCKER_IMAGE_TAG"
  rules:
    - if: '$BUILD_PUSH=="true" || $BUILD_PUSH == ""'

build-docker-image-local:
  stage: build
  image: docker:24
  services:
    - docker:24-dind
  variables:
    DOCKER_TLS_CERTDIR: "/certs"
  script: |
    echo "============================================================================"
    echo "Building Docker Image (Local Only - No Push)"
    echo "============================================================================"
    cd "$CI_PROJECT_DIR/app"
    docker build -t "$APP_NAME:latest" .
    echo ""
    echo "âœ… Docker image built successfully (not pushed)"
  rules:
    - if: '$BUILD_PUSH=="false"'

# DEPLOY LOCAL STAGE (Minikube, Kind, K3s, etc.)
deploy-local:
  stage: deploy-local
  image: debian:11
  dependencies:
    - build-docker-image
    - build-docker-image-local
  before_script:
    - apt-get update -y
    - apt-get install -y --no-install-recommends \
        curl \
        bash \
        git \
        ca-certificates \
        gnupg \
        lsb-release \
        software-properties-common
    # Install kubectl
    - curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
    - install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
    - kubectl version --client
    - mkdir -p $HOME/.kube
    - echo "$KUBECONFIG_PROD" | base64 -d > $HOME/.kube/config
    - chmod 600 $HOME/.kube/config
    - kubectl config use-context "$KUBE_CONTEXT" || true
  script: |
    echo "============================================================================"
    echo "Deploying to Local Kubernetes Environment"
    echo "============================================================================"

    if [[ "$CI" == "true" && "$DEPLOY_TARGET" == "local" ]]; then
      echo "âš ï¸  Skipping local Kubernetes deployment in CI"
      exit 0
    fi
    CONTEXT=$(kubectl config current-context 2>/dev/null || echo "")
      
    if kubectl get nodes -o json 2>/dev/null | grep -q '"minikube.k8s.io/version"'; then
      K8S_DIST="minikube"
    elif [[ "$CONTEXT" == *"kind"* ]] || kubectl get nodes -o json 2>/dev/null | grep -q "kind-control-plane"; then
      K8S_DIST="kind"
    elif kubectl get nodes -o json 2>/dev/null | grep -q '"k3s.io"'; then
      K8S_DIST="k3s"
    elif kubectl get nodes -o json 2>/dev/null | grep -q '"microk8s.io"'; then
      K8S_DIST="microk8s"
    else
      K8S_DIST="kubernetes"
    fi
    export K8S_DISTRIBUTION=$K8S_DIST
    export K8S_CONTEXT=$CONTEXT
    echo "âœ… Connected to: $K8S_DIST"
    echo "   Context: $CONTEXT"
    echo ""
    echo "============================================================================"
    echo "Deployment Information"
    echo "============================================================================"
    kubectl get pods -n $NAMESPACE || true
    kubectl get svc -n $NAMESPACE || true
    kubectl get ingress -n $NAMESPACE || true
  rules:
    - if: '$DEPLOY_TARGET == "local"'

# DEPLOY PRODUCTION STAGE (EKS, GKE, AKS)
deploy:terraform-infrastructure:
  stage: deploy-prod
  image: 
    name: hashicorp/terraform:1.6
    entrypoint: [""]
  before_script:
    - apk add --no-cache bash aws-cli
    # Configure AWS credentials
    - mkdir -p $HOME/.aws
    - |
      cat > $HOME/.aws/credentials <<EOF
      [default]
      aws_access_key_id = $AWS_ACCESS_KEY_ID
      aws_secret_access_key = $AWS_SECRET_ACCESS_KEY
      EOF
    - |
      cat > $HOME/.aws/config <<EOF
      [default]
      region = $AWS_REGION
      output = json
      EOF
  script:
    - |
      echo "============================================================================"
      echo "Deploying Infrastructure with Terraform"
      echo "============================================================================"
      
      cd "$CI_PROJECT_DIR/infra/terraform"
      
      terraform init -upgrade
      terraform validate
      terraform plan -out=tfplan
      
      if [ "$DRY_RUN" == "true" ]; then
        echo "ðŸ” DRY RUN MODE - Skipping apply"
      else
        terraform apply -auto-approve tfplan
        
        # Update kubeconfig for EKS
        REGION=$(terraform output -raw region)
        CLUSTER_NAME=$(terraform output -raw cluster_name)
        
        aws eks update-kubeconfig \
          --region "$REGION" \
          --name "$CLUSTER_NAME"
      fi
  artifacts:
    paths:
      - infra/terraform/tfplan
      - infra/terraform/.terraform/
    expire_in: 1 day
  environment:
    name: production/infrastructure
  rules:
    - if: '$DEPLOY_TARGET == "prod"'
    - if: '$K8S_DISTRIBUTION == "eks"'
  tags:
    - terraform

deploy:production:
  stage: deploy-prod
  image: 
    name: alpine/k8s:1.28.3
    entrypoint: [""]
  needs:
    - deploy:terraform-infrastructure
  before_script:
    - apk add --no-cache bash git docker-cli aws-cli
    # Configure AWS credentials
    - mkdir -p $HOME/.aws
    - |
      cat > $HOME/.aws/credentials <<EOF
      [default]
      aws_access_key_id = $AWS_ACCESS_KEY_ID
      aws_secret_access_key = $AWS_SECRET_ACCESS_KEY
      EOF
    - |
      cat > $HOME/.aws/config <<EOF
      [default]
      region = $AWS_REGION
      output = json
      EOF
    # Configure kubectl
    - mkdir -p $HOME/.kube
    - aws eks update-kubeconfig --region "$AWS_REGION" --name "$EKS_CLUSTER_NAME"
  script:
    - |
      echo "============================================================================"
      echo "Deploying to Production Kubernetes (Cloud)"
      echo "============================================================================"
      
      export PROJECT_ROOT=$CI_PROJECT_DIR
      
      # Detect Kubernetes cluster
      echo ""
      echo "ðŸ” Detecting Kubernetes cluster..."
      
      if ! kubectl cluster-info >/dev/null 2>&1; then
        echo "âŒ Cannot connect to Kubernetes cluster"
        exit 1
      fi
      
      K8S_DIST="unknown"
      
      if kubectl get nodes -o json 2>/dev/null | grep -q '"eks.amazonaws.com"'; then
        K8S_DIST="eks"
      elif kubectl get nodes -o json 2>/dev/null | grep -q '"cloud.google.com/gke"'; then
        K8S_DIST="gke"
      elif kubectl get nodes -o json 2>/dev/null | grep -q '"kubernetes.azure.com"'; then
        K8S_DIST="aks"
      else
        K8S_DIST="kubernetes"
      fi
      
      export K8S_DISTRIBUTION="$K8S_DIST"
      
      echo "âœ… Connected to: $K8S_DIST"
      
      # Configure Git
      echo ""
      echo "âš™ï¸  Configuring Git..."
      source "$CI_PROJECT_DIR/cicd/github/configure_git_github.sh"
      configure_git_github
      
      # Deploy Kubernetes resources
      echo ""
      echo "ðŸ“¦ Deploying Kubernetes resources..."
      source "$CI_PROJECT_DIR/kubernetes/deploy_kubernetes.sh"
      deploy_kubernetes prod
      
      echo ""
      echo "âœ… Application deployed to $K8S_DIST"
      echo ""
      echo "â„¹ï¸  Check LoadBalancer or Ingress for external access:"
      kubectl get svc -n "$NAMESPACE"
      kubectl get ingress -n "$NAMESPACE"
  environment:
    name: production
    url: https://$INGRESS_HOST
  rules: 
    - if: '$DEPLOY_TARGET == "prod"'
  tags:
    - kubernetes

# MONITORING STAGE
deploy-monitoring:
  stage: monitoring
  image: docker:24
  services:
    - docker:24-dind
  dependencies:
    - deploy-local
  before_script:
    - apk add --no-cache bash curl git
    - curl -Lo kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64
    - chmod +x kind
    - mv kind /usr/local/bin/kind
  script: |
    echo "============================================================================"
    echo "Deploying Monitoring Stack (Prometheus + Grafana)"
    echo "============================================================================"
    kind create cluster --name devops-ci --wait 60s
    export KUBECONFIG="$(kind get kubeconfig-path --name="devops-ci")"
    kubectl cluster-info
    docker build -t "$APP_NAME:$IMAGE_TAG" ./app
    kind load docker-image "$APP_NAME:$IMAGE_TAG" --name devops-ci
    source ./kubernetes/deploy_kubernetes.sh
    deploy_kubernetes local
    source ./monitoring/deploy_monitoring.sh
    deploy_monitoring
    echo ""
    echo "âœ… Monitoring stack deployed successfully"
    echo ""
    echo "============================================================================"
    echo "Monitoring Stack Information"
    echo "============================================================================"
    kubectl get pods -n $PROMETHEUS_NAMESPACE || true
    kubectl get svc -n $PROMETHEUS_NAMESPACE || true
    kind delete cluster --name devops-ci
  rules:
    - if: '$PROMETHEUS_ENABLED == "true"'

# CLEANUP JOBS
cleanup:local:
  stage: deploy-local
  image: debian:11
  before_script:
    - apt-get update -y
    - apt-get install -y --no-install-recommends \
        curl \
        bash \
        git \
        ca-certificates \
        gnupg \
        lsb-release \
        software-properties-common
        
    # Install kubectl
    - curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
    - install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
    - kubectl version --client

    # Setup kubeconfig
    - mkdir -p $HOME/.kube
    - echo "$KUBECONFIG_PROD" | base64 -d > $HOME/.kube/config
    - chmod 600 $HOME/.kube/config
    - kubectl config use-context "$KUBE_CONTEXT" || true
  script:
    - |
      echo "============================================================================"
      echo "Cleaning up Local Environment"
      echo "============================================================================"
      
      kubectl delete namespace "$NAMESPACE" --ignore-not-found=true
      kubectl delete namespace "$PROMETHEUS_NAMESPACE" --ignore-not-found=true
      
      echo "âœ… Cleanup completed"
  when: manual
  environment:
    name: local
    action: stop
  tags:
    - kubernetes