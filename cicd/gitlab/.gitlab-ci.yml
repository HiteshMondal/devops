stages:
  - deploy

variables:
  PROJECT_ROOT: "$CI_PROJECT_DIR"
  APP_NAME: devops-app
  NAMESPACE: devops-app
  IMAGE_NAME: devops-app
  IMAGE_TAG: latest
  KUBE_CONTEXT: minikube

deploy_minikube:
  stage: deploy
  tags:
    - self-hosted
    - minikube
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'

  script:
    - echo "ğŸš€ Production CI/CD (Minikube) â€“ GitLab"

    # Tool sanity checks
    - |
      docker --version
      kubectl version --client
      minikube version
      node --version || true

    # Install app dependencies
    - |
      echo "ğŸ“¦ Installing Node.js dependencies"
      cd app
      npm install
      cd ..

    # Ensure Minikube is running
    - |
      if [[ "$(minikube status --format='{{.Host}}')" != "Running" ]]; then
        echo "ğŸ”§ Starting Minikube..."
        minikube start --driver=docker
        minikube addons enable ingress
      fi

    # Build Docker image inside Minikube
    - |
      echo "ğŸ³ Building Docker image inside Minikube"
      eval "$(minikube docker-env)"
      docker build -t "$IMAGE_NAME:$IMAGE_TAG" ./app

    # Deploy application (Kustomize)
    - |
      echo "ğŸ“¦ Deploying application via Kustomize"
      kubectl config use-context "$KUBE_CONTEXT"
      kubectl kustomize kubernetes/overlays/local | kubectl apply -f -

    # Deploy Monitoring Stack
    - |
      echo "ğŸ“Š Deploying Monitoring Stack"

      BASE_MONITORING_PATH="$PROJECT_ROOT/kubernetes/base/monitoring"
      PROM_CONFIG="$PROJECT_ROOT/monitoring/prometheus/prometheus.yml"
      PROM_ALERTS="$PROJECT_ROOT/monitoring/prometheus/alerts.yml"

      kubectl apply -f - <<EOF
      apiVersion: v1
      kind: Namespace
      metadata:
        name: monitoring
      EOF

      # Default password if CI variable not set
      if [ -z "$GRAFANA_ADMIN_PASSWORD" ]; then
        GRAFANA_ADMIN_PASSWORD=admin123
      fi

      kubectl create secret generic grafana-secrets \
        --from-literal=admin-password="$GRAFANA_ADMIN_PASSWORD" \
        -n monitoring \
        --dry-run=client -o yaml | kubectl apply -f -

      kubectl apply -f "$BASE_MONITORING_PATH/dashboard-configmap.yaml"

      kubectl create configmap prometheus-config \
        --from-file=prometheus.yml="$PROM_CONFIG" \
        --from-file=alerts.yml="$PROM_ALERTS" \
        -n monitoring \
        --dry-run=client -o yaml | kubectl apply -f -

      kubectl create configmap grafana-datasource \
        --from-literal=datasource.yaml="apiVersion: 1
      datasources:
        - name: Prometheus
          type: prometheus
          access: proxy
          url: http://prometheus.monitoring.svc.cluster.local:9090
          isDefault: true" \
        -n monitoring \
        --dry-run=client -o yaml | kubectl apply -f -

      kubectl create configmap grafana-dashboard \
        --from-literal=dummy=empty \
        -n monitoring \
        --dry-run=client -o yaml | kubectl apply -f -

      kubectl create configmap grafana-dashboard-config \
        --from-literal=dummy=empty \
        -n monitoring \
        --dry-run=client -o yaml | kubectl apply -f -

      kubectl apply -f "$BASE_MONITORING_PATH/prometheus.yaml"
      kubectl apply -f "$BASE_MONITORING_PATH/grafana.yaml"
      kubectl rollout restart deployment/prometheus -n monitoring
      kubectl rollout restart deployment/grafana -n monitoring

    # Expose Monitoring (NodePort)
    - |
      kubectl apply -f - <<EOF
      apiVersion: v1
      kind: Service
      metadata:
        name: prometheus
        namespace: monitoring
      spec:
        selector:
          app: prometheus
        ports:
          - port: 9090
            targetPort: 9090
        type: NodePort
      ---
      apiVersion: v1
      kind: Service
      metadata:
        name: grafana
        namespace: monitoring
      spec:
        selector:
          app: grafana
        ports:
          - port: 3000
            targetPort: 3000
        type: NodePort
      EOF

    # Wait for rollouts & output URLs
    - |
      kubectl rollout status deployment/prometheus -n monitoring --timeout=300s

      until kubectl get pods -n monitoring -l app=grafana --no-headers | grep Running; do
        echo "â³ Waiting for Grafana pod..."
        sleep 5
      done

      kubectl rollout status deployment/grafana -n monitoring --timeout=300s

      MINIKUBE_IP=$(minikube ip)

      APP_PORT=$(kubectl get svc devops-app-service -n devops-app \
        -o jsonpath='{.spec.ports[0].nodePort}')

      PROM_PORT=$(kubectl get svc prometheus -n monitoring \
        -o jsonpath='{.spec.ports[0].nodePort}')

      GRAF_PORT=$(kubectl get svc grafana -n monitoring \
        -o jsonpath='{.spec.ports[0].nodePort}')

      echo ""
      echo "## ğŸš€ Deployment URLs"
      echo "- App: http://$MINIKUBE_IP:$APP_PORT"
      echo "- Prometheus: http://$MINIKUBE_IP:$PROM_PORT"
      echo "- Grafana: http://$MINIKUBE_IP:$GRAF_PORT"
