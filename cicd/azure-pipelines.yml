################################################################################
# 4. AZURE DEVOPS PIPELINE
################################################################################
---
# File: azure-pipelines.yml
trigger:
  branches:
    include:
      - main
      - develop
      - feature/*
  paths:
    include:
      - services/backend-api/**
      - infrastructure/**

pr:
  branches:
    include:
      - main
      - develop

variables:
  - group: production-secrets
  - name: dockerRegistryServiceConnection
    value: 'docker-hub-connection'
  - name: imageRepository
    value: 'backend-api'
  - name: containerRegistry
    value: 'mycompany.azurecr.io'
  - name: dockerfilePath
    value: 'services/backend-api/Dockerfile'
  - name: tag
    value: '$(Build.BuildId)'
  - name: vmImageName
    value: 'ubuntu-latest'
  - name: kubernetesServiceConnection
    value: 'aks-production'
  - name: namespace
    value: 'production'

stages:
  - stage: Build
    displayName: Build and Test
    jobs:
      - job: CodeQuality
        displayName: Code Quality Analysis
        pool:
          vmImage: $(vmImageName)
        steps:
          - task: NodeTool@0
            inputs:
              versionSpec: '20.x'
            displayName: 'Install Node.js'

          - script: |
              cd services/backend-api
              npm ci
              npm run lint
              npm run format:check
            displayName: 'Lint and Format Check'

          - task: SonarCloudPrepare@1
            inputs:
              SonarCloud: 'SonarCloud'
              organization: 'myorg'
              scannerMode: 'CLI'
              configMode: 'file'

          - task: SonarCloudAnalyze@1
            displayName: 'Run SonarCloud Analysis'

          - task: SonarCloudPublish@1
            inputs:
              pollingTimeoutSec: '300'

      - job: UnitTests
        displayName: Unit and Integration Tests
        pool:
          vmImage: $(vmImageName)
        services:
          postgres:
            image: postgres:16-alpine
            env:
              POSTGRES_DB: testdb
              POSTGRES_USER: testuser
              POSTGRES_PASSWORD: testpass
            ports:
              - 5432:5432
        steps:
          - task: NodeTool@0
            inputs:
              versionSpec: '20.x'

          - script: |
              cd services/backend-api
              npm ci
              npm run test:unit -- --coverage --ci
              npm run test:integration
            displayName: 'Run Tests'
            env:
              DATABASE_URL: postgresql://testuser:testpass@localhost:5432/testdb

          - task: PublishTestResults@2
            inputs:
              testResultsFormat: 'JUnit'
              testResultsFiles: '**/junit.xml'
              failTaskOnFailedTests: true

          - task: PublishCodeCoverageResults@1
            inputs:
              codeCoverageTool: 'Cobertura'
              summaryFileLocation: '$(System.DefaultWorkingDirectory)/services/backend-api/coverage/cobertura-coverage.xml'

      - job: BuildDocker
        displayName: Build Docker Image
        dependsOn:
          - CodeQuality
          - UnitTests
        pool:
          vmImage: $(vmImageName)
        steps:
          - task: Docker@2
            displayName: Build and push image
            inputs:
              command: buildAndPush
              repository: $(imageRepository)
              dockerfile: $(dockerfilePath)
              containerRegistry: $(dockerRegistryServiceConnection)
              tags: |
                $(tag)
                latest

          - task: AquaScanner@1
            displayName: 'Scan Docker Image with Trivy'
            inputs:
              image: '$(containerRegistry)/$(imageRepository):$(tag)'
              scanner: 'Trivy'
              scanType: 'Image'
              severity: 'HIGH,CRITICAL'

          - publish: $(System.DefaultWorkingDirectory)/infrastructure/kubernetes
            artifact: manifests

  - stage: DeployStaging
    displayName: Deploy to Staging
    dependsOn: Build
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/develop'))
    jobs:
      - deployment: DeployStaging
        displayName: Deploy to Staging Environment
        pool:
          vmImage: $(vmImageName)
        environment: 'staging'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: KubernetesManifest@0
                  displayName: Create/Update Deployment
                  inputs:
                    action: deploy
                    kubernetesServiceConnection: $(kubernetesServiceConnection)
                    namespace: staging
                    manifests: |
                      $(Pipeline.Workspace)/manifests/overlays/staging/*.yaml
                    containers: |
                      $(containerRegistry)/$(imageRepository):$(tag)

                - task: Kubernetes@1
                  displayName: Check Rollout Status
                  inputs:
                    connectionType: 'Kubernetes Service Connection'
                    kubernetesServiceEndpoint: $(kubernetesServiceConnection)
                    namespace: 'staging'
                    command: 'rollout'
                    arguments: 'status deployment/backend-api'

                - script: |
                    chmod +x $(Pipeline.Workspace)/scripts/health-check.sh
                    $(Pipeline.Workspace)/scripts/health-check.sh https://api-staging.example.com
                  displayName: 'Run Smoke Tests'

  - stage: DeployProduction
    displayName: Deploy to Production
    dependsOn: Build
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
      - deployment: DeployProduction
        displayName: Deploy to Production Environment
        pool:
          vmImage: $(vmImageName)
        environment: 'production'
        strategy:
          canary:
            increments: [10, 25, 50, 100]
            preDeploy:
              steps:
                - script: echo "Pre-deployment checks"

            deploy:
              steps:
                - task: KubernetesManifest@0
                  displayName: Deploy Canary
                  inputs:
                    action: deploy
                    kubernetesServiceConnection: $(kubernetesServiceConnection)
                    namespace: $(namespace)
                    manifests: |
                      $(Pipeline.Workspace)/manifests/overlays/production/*.yaml
                    containers: |
                      $(containerRegistry)/$(imageRepository):$(tag)
                    percentage: $(strategy.increment)

            routeTraffic:
              steps:
                - task: Kubernetes@1
                  inputs:
                    connectionType: 'Kubernetes Service Connection'
                    kubernetesServiceEndpoint: $(kubernetesServiceConnection)
                    namespace: $(namespace)
                    command: 'set'
                    arguments: 'image deployment/backend-api backend-api=$(containerRegistry)/$(imageRepository):$(tag)'

            postRouteTraffic:
              steps:
                - script: |
                    echo "Monitoring canary deployment..."
                    sleep 60
                    # Check metrics
                  displayName: 'Monitor Canary'

            on:
              failure:
                steps:
                  - task: Kubernetes@1
                    displayName: 'Rollback on Failure'
                    inputs:
                      connectionType: 'Kubernetes Service Connection'
                      kubernetesServiceEndpoint: $(kubernetesServiceConnection)
                      namespace: $(namespace)
                      command: 'rollout'
                      arguments: 'undo deployment/backend-api'

              success:
                steps:
                  - task: GitHubRelease@1
                    inputs:
                      gitHubConnection: 'github-connection'
                      repositoryName: '$(Build.Repository.Name)'
                      action: 'create'
                      target: '$(Build.SourceVersion)'
                      tagSource: 'userSpecifiedTag'
                      tag: 'v$(Build.BuildId)'
                      title: 'Release v$(Build.BuildId)'
                      releaseNotesSource: 'inline'
                      releaseNotesInline: |
                        Automated release from Azure DevOps
                        Build: $(Build.BuildNumber)
                        Commit: $(Build.SourceVersion)
