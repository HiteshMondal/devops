name: DevOps Project Deployment (Production & Local)

# ============================================================================
# UPDATED: This workflow now supports both LOCAL (Minikube) and PROD (EKS) deployments!
# ============================================================================
# - /.github/workflows/prod.yml
# - For LOCAL development: Choose 'local' target - runs Minikube in GitHub Actions
# - For PRODUCTION deployment to AWS EKS: Choose 'prod' target
# ============================================================================

on:
  push:
    branches:
      - main
      - develop
  pull_request:
    branches:
      - main
  workflow_dispatch:
    inputs:
      deploy_target:
        description: 'Deployment target'
        required: true
        default: 'local'
        type: choice
        options:
          - local
          - prod
      build_push:
        description: 'Build and push Docker image'
        required: false
        default: 'true'
        type: boolean

env:
  # Core Application Settings
  APP_NAME: ${{ vars.APP_NAME || 'devops-app' }}
  NAMESPACE: ${{ vars.NAMESPACE || 'devops' }}
  DOCKERHUB_USERNAME: ${{ vars.DOCKERHUB_USERNAME }}
  DOCKER_IMAGE_TAG: ${{ vars.DOCKER_IMAGE_TAG || github.sha }}
  APP_PORT: ${{ vars.APP_PORT || '3000' }}
  
  # Deployment Configuration
  REPLICAS: ${{ vars.REPLICAS || '2' }}
  MIN_REPLICAS: ${{ vars.MIN_REPLICAS || '2' }}
  MAX_REPLICAS: ${{ vars.MAX_REPLICAS || '10' }}
  CPU_TARGET_UTILIZATION: ${{ vars.CPU_TARGET_UTILIZATION || '80' }}
  MEMORY_TARGET_UTILIZATION: ${{ vars.MEMORY_TARGET_UTILIZATION || '80' }}
  
  # Resource Limits
  APP_CPU_REQUEST: ${{ vars.APP_CPU_REQUEST || '100m' }}
  APP_CPU_LIMIT: ${{ vars.APP_CPU_LIMIT || '500m' }}
  APP_MEMORY_REQUEST: ${{ vars.APP_MEMORY_REQUEST || '128Mi' }}
  APP_MEMORY_LIMIT: ${{ vars.APP_MEMORY_LIMIT || '512Mi' }}
  
  # Database Configuration (from secrets)
  DB_HOST: ${{ secrets.DB_HOST }}
  DB_PORT: ${{ secrets.DB_PORT || '5432' }}
  DB_NAME: ${{ secrets.DB_NAME }}
  DB_USERNAME: ${{ secrets.DB_USERNAME }}
  DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
  
  # Application Secrets
  JWT_SECRET: ${{ secrets.JWT_SECRET }}
  API_KEY: ${{ secrets.API_KEY }}
  SESSION_SECRET: ${{ secrets.SESSION_SECRET }}
  
  # Ingress Configuration
  INGRESS_ENABLED: ${{ vars.INGRESS_ENABLED || 'true' }}
  INGRESS_HOST: ${{ vars.INGRESS_HOST || 'app.example.com' }}
  INGRESS_CLASS: ${{ vars.INGRESS_CLASS || 'nginx' }}
  TLS_SECRET_NAME: ${{ vars.TLS_SECRET_NAME || 'app-tls' }}
  
  # Monitoring Configuration
  PROMETHEUS_ENABLED: ${{ vars.PROMETHEUS_ENABLED || 'true' }}
  PROMETHEUS_NAMESPACE: ${{ vars.PROMETHEUS_NAMESPACE || 'monitoring' }}
  PROMETHEUS_SCRAPE_INTERVAL: ${{ vars.PROMETHEUS_SCRAPE_INTERVAL || '30s' }}
  PROMETHEUS_SCRAPE_TIMEOUT: ${{ vars.PROMETHEUS_SCRAPE_TIMEOUT || '10s' }}
  PROMETHEUS_RETENTION: ${{ vars.PROMETHEUS_RETENTION || '15d' }}
  PROMETHEUS_STORAGE_SIZE: ${{ vars.PROMETHEUS_STORAGE_SIZE || '10Gi' }}
  
  # Prometheus Resource Limits
  PROMETHEUS_CPU_REQUEST: ${{ vars.PROMETHEUS_CPU_REQUEST || '200m' }}
  PROMETHEUS_CPU_LIMIT: ${{ vars.PROMETHEUS_CPU_LIMIT || '1000m' }}
  PROMETHEUS_MEMORY_REQUEST: ${{ vars.PROMETHEUS_MEMORY_REQUEST || '512Mi' }}
  PROMETHEUS_MEMORY_LIMIT: ${{ vars.PROMETHEUS_MEMORY_LIMIT || '2Gi' }}
  
  # Grafana Configuration
  GRAFANA_ENABLED: ${{ vars.GRAFANA_ENABLED || 'true' }}
  GRAFANA_ADMIN_USER: ${{ secrets.GRAFANA_ADMIN_USER || 'admin' }}
  GRAFANA_ADMIN_PASSWORD: ${{ secrets.GRAFANA_ADMIN_PASSWORD }}
  GRAFANA_STORAGE_SIZE: ${{ vars.GRAFANA_STORAGE_SIZE || '5Gi' }}
  GRAFANA_CPU_REQUEST: ${{ vars.GRAFANA_CPU_REQUEST || '100m' }}
  GRAFANA_CPU_LIMIT: ${{ vars.GRAFANA_CPU_LIMIT || '500m' }}
  GRAFANA_MEMORY_REQUEST: ${{ vars.GRAFANA_MEMORY_REQUEST || '256Mi' }}
  GRAFANA_MEMORY_LIMIT: ${{ vars.GRAFANA_MEMORY_LIMIT || '1Gi' }}
  
  # Git Configuration
  GIT_USER_NAME: ${{ vars.GIT_USER_NAME || github.actor }}
  GIT_USER_EMAIL: ${{ vars.GIT_USER_EMAIL || format('{0}@users.noreply.github.com', github.actor) }}
  
  # Minikube Configuration (for local deployments)
  MINIKUBE_INGRESS: ${{ vars.MINIKUBE_INGRESS || 'true' }}
  
  # Deployment Target
  DEPLOY_TARGET: ${{ github.event.inputs.deploy_target || vars.DEPLOY_TARGET || 'local' }}
  BUILD_PUSH: ${{ github.event.inputs.build_push || vars.BUILD_PUSH || 'true' }}
  
  # AWS Configuration (for prod deployments)
  AWS_REGION: ${{ vars.AWS_REGION || 'us-east-1' }}

jobs:
  validate-configuration:
    name: Validate Configuration
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Validate required variables
        run: |
          echo "üîç Validating configuration..."
          
          # Check required variables
          MISSING_VARS=()
          
          [[ -z "${{ vars.APP_NAME }}" ]] && MISSING_VARS+=("APP_NAME")
          [[ -z "${{ vars.NAMESPACE }}" ]] && MISSING_VARS+=("NAMESPACE")
          [[ -z "${{ vars.DOCKERHUB_USERNAME }}" ]] && MISSING_VARS+=("DOCKERHUB_USERNAME")
          
          if [ ${#MISSING_VARS[@]} -gt 0 ]; then
            echo "‚ùå Missing required variables:"
            printf '   - %s\n' "${MISSING_VARS[@]}"
            echo ""
            echo "Please configure these in GitHub repository settings:"
            echo "Settings ‚Üí Secrets and variables ‚Üí Actions ‚Üí Variables"
            exit 1
          fi
          
          echo "‚úÖ All required variables are present"
      
      - name: Validate required secrets
        run: |
          echo "üîç Validating secrets..."
          
          MISSING_SECRETS=()
          
          [[ -z "${{ secrets.DOCKERHUB_PASSWORD }}" ]] && MISSING_SECRETS+=("DOCKERHUB_PASSWORD")
          
          if [ "${{ env.DEPLOY_TARGET }}" == "prod" ]; then
            [[ -z "${{ secrets.AWS_ACCESS_KEY_ID }}" ]] && MISSING_SECRETS+=("AWS_ACCESS_KEY_ID")
            [[ -z "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ]] && MISSING_SECRETS+=("AWS_SECRET_ACCESS_KEY")
          fi
          
          if [ ${#MISSING_SECRETS[@]} -gt 0 ]; then
            echo "‚ùå Missing required secrets:"
            printf '   - %s\n' "${MISSING_SECRETS[@]}"
            echo ""
            echo "Please configure these in GitHub repository settings:"
            echo "Settings ‚Üí Secrets and variables ‚Üí Actions ‚Üí Secrets"
            exit 1
          fi
          
          echo "‚úÖ All required secrets are present"
      
      - name: Display deployment configuration
        run: |
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "Deployment Configuration"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "üéØ Deployment Target: ${{ env.DEPLOY_TARGET }}"
          echo "üì¶ Application: ${{ env.APP_NAME }}"
          echo "üè∑Ô∏è  Image Tag: ${{ env.DOCKER_IMAGE_TAG }}"
          echo "üî¢ Replicas: ${{ env.REPLICAS }}"
          echo "üåê Namespace: ${{ env.NAMESPACE }}"
          echo "üî® Build & Push: ${{ env.BUILD_PUSH }}"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          
          if [[ "${{ env.DEPLOY_TARGET }}" == "local" ]]; then
            echo ""
            echo "üìç LOCAL DEPLOYMENT MODE"
            echo ""
            echo "This workflow will:"
            echo "  ‚úÖ Set up Minikube in GitHub Actions runner"
            echo "  ‚úÖ Build and push Docker image (if enabled)"
            echo "  ‚úÖ Deploy Kubernetes resources to Minikube"
            echo "  ‚úÖ Deploy monitoring stack (Prometheus & Grafana)"
            echo ""
          else
            echo ""
            echo "‚òÅÔ∏è  PRODUCTION DEPLOYMENT MODE"
            echo ""
            echo "This workflow will:"
            echo "  ‚úÖ Provision AWS infrastructure with Terraform"
            echo "  ‚úÖ Build and push Docker image"
            echo "  ‚úÖ Deploy to AWS EKS cluster"
            echo "  ‚úÖ Deploy monitoring stack"
            echo ""
          fi

  build-and-push-image:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: validate-configuration
    if: ${{ github.event.inputs.build_push != 'false' && vars.BUILD_PUSH != 'false' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./app
          file: ./app/Dockerfile
          push: true
          tags: |
            ${{ vars.DOCKERHUB_USERNAME }}/${{ env.APP_NAME }}:${{ env.DOCKER_IMAGE_TAG }}
            ${{ vars.DOCKERHUB_USERNAME }}/${{ env.APP_NAME }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
      
      - name: Image build summary
        run: |
          echo "‚úÖ Docker image built and pushed successfully!"
          echo "üì¶ Image: ${{ vars.DOCKERHUB_USERNAME }}/${{ env.APP_NAME }}:${{ env.DOCKER_IMAGE_TAG }}"

  setup-minikube:
    name: Setup Minikube (Local)
    runs-on: ubuntu-latest
    needs: validate-configuration
    if: ${{ github.event.inputs.deploy_target == 'local' || vars.DEPLOY_TARGET == 'local' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Start Minikube
        uses: medyagh/setup-minikube@latest
        with:
          cpus: 2
          memory: 4096
          kubernetes-version: v1.28.0
          driver: docker
      
      - name: Enable Minikube addons
        run: |
          echo "üîß Enabling Minikube addons..."
          minikube addons enable ingress
          minikube addons enable metrics-server
          echo "‚úÖ Addons enabled successfully"
      
      - name: Verify Minikube setup
        run: |
          echo "üîç Verifying Minikube setup..."
          kubectl cluster-info
          kubectl get nodes
          echo "‚úÖ Minikube is ready!"
      
      - name: Save kubeconfig
        run: |
          mkdir -p $HOME/.kube
          kubectl config view --raw > $HOME/.kube/config
          echo "KUBECONFIG=$HOME/.kube/config" >> $GITHUB_ENV

  deploy-infrastructure-prod:
    name: Deploy AWS Infrastructure (Terraform)
    runs-on: ubuntu-latest
    needs: validate-configuration
    if: ${{ (github.event.inputs.deploy_target == 'prod' || vars.DEPLOY_TARGET == 'prod') && github.ref == 'refs/heads/main' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: latest
      
      - name: Terraform Init
        working-directory: ./infra/terraform
        run: terraform init -upgrade
      
      - name: Terraform Plan
        working-directory: ./infra/terraform
        run: terraform plan -out=tfplan
      
      - name: Terraform Apply
        working-directory: ./infra/terraform
        run: terraform apply -auto-approve tfplan
      
      - name: Configure kubectl for EKS
        run: |
          aws eks update-kubeconfig \
            --region ${{ env.AWS_REGION }} \
            --name $(cd infra/terraform && terraform output -raw cluster_name)
      
      - name: Verify cluster connection
        run: |
          kubectl cluster-info
          kubectl get nodes

  deploy-kubernetes-local:
    name: Deploy Kubernetes Resources (Minikube)
    runs-on: ubuntu-latest
    needs: [build-and-push-image, setup-minikube]
    if: |
      always() &&
      needs.validate-configuration.result == 'success' &&
      (needs.build-and-push-image.result == 'success' || needs.build-and-push-image.result == 'skipped') &&
      needs.setup-minikube.result == 'success' &&
      (github.event.inputs.deploy_target == 'local' || vars.DEPLOY_TARGET == 'local')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Start Minikube
        uses: medyagh/setup-minikube@latest
        with:
          cpus: 2
          memory: 4096
          kubernetes-version: v1.28.0
          driver: docker
      
      - name: Enable Minikube addons
        run: |
          minikube addons enable ingress
          minikube addons enable metrics-server
      
      - name: Verify Minikube is running
        run: |
          echo "üîç Verifying Minikube connectivity..."
          kubectl cluster-info
          kubectl get nodes
          echo "‚úÖ Connected to Minikube cluster"
      
      - name: Install envsubst
        run: |
          sudo apt-get update
          sudo apt-get install -y gettext-base
      
      - name: Substitute environment variables in manifests
        run: |
          echo "üìù Processing Kubernetes manifests..."
          
          # Create temporary working directory
          WORK_DIR="/tmp/k8s-deployment-$$"
          mkdir -p "$WORK_DIR"
          
          # Copy manifests
          cp -r kubernetes/base "$WORK_DIR/"
          cp -r kubernetes/overlays "$WORK_DIR/"
          
          # Export all environment variables for envsubst
          export APP_NAME="${{ env.APP_NAME }}"
          export NAMESPACE="${{ env.NAMESPACE }}"
          export DOCKERHUB_USERNAME="${{ vars.DOCKERHUB_USERNAME }}"
          export DOCKER_IMAGE_TAG="${{ env.DOCKER_IMAGE_TAG }}"
          export APP_PORT="${{ env.APP_PORT }}"
          export REPLICAS="${{ env.REPLICAS }}"
          export MIN_REPLICAS="${{ env.MIN_REPLICAS }}"
          export MAX_REPLICAS="${{ env.MAX_REPLICAS }}"
          export CPU_TARGET_UTILIZATION="${{ env.CPU_TARGET_UTILIZATION }}"
          export MEMORY_TARGET_UTILIZATION="${{ env.MEMORY_TARGET_UTILIZATION }}"
          export APP_CPU_REQUEST="${{ env.APP_CPU_REQUEST }}"
          export APP_CPU_LIMIT="${{ env.APP_CPU_LIMIT }}"
          export APP_MEMORY_REQUEST="${{ env.APP_MEMORY_REQUEST }}"
          export APP_MEMORY_LIMIT="${{ env.APP_MEMORY_LIMIT }}"
          export DB_HOST="${{ secrets.DB_HOST }}"
          export DB_PORT="${{ secrets.DB_PORT }}"
          export DB_NAME="${{ secrets.DB_NAME }}"
          export DB_USERNAME="${{ secrets.DB_USERNAME }}"
          export DB_PASSWORD="${{ secrets.DB_PASSWORD }}"
          export JWT_SECRET="${{ secrets.JWT_SECRET }}"
          export API_KEY="${{ secrets.API_KEY }}"
          export SESSION_SECRET="${{ secrets.SESSION_SECRET }}"
          export INGRESS_HOST="${{ env.INGRESS_HOST }}"
          export INGRESS_CLASS="${{ env.INGRESS_CLASS }}"
          export TLS_SECRET_NAME="${{ env.TLS_SECRET_NAME }}"
          export PROMETHEUS_NAMESPACE="${{ env.PROMETHEUS_NAMESPACE }}"
          
          # Process all YAML files
          find "$WORK_DIR" -type f \( -name "*.yaml" -o -name "*.yml" \) | while read -r file; do
            echo "  Processing: $file"
            envsubst < "$file" > "${file}.tmp"
            mv "${file}.tmp" "$file"
          done
          
          # Save processed manifests for deployment
          echo "WORK_DIR=$WORK_DIR" >> $GITHUB_ENV
      
      - name: Create namespace
        run: |
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
      
      - name: Deploy base Kubernetes resources
        run: |
          echo "üîß Deploying base Kubernetes resources to Minikube..."
          
          kubectl apply -f "$WORK_DIR/base/namespace.yaml" || true
          kubectl apply -f "$WORK_DIR/base/configmap.yaml"
          kubectl apply -f "$WORK_DIR/base/secrets.yaml"
          kubectl apply -f "$WORK_DIR/base/deployment.yaml"
          kubectl apply -f "$WORK_DIR/base/service.yaml"
          kubectl apply -f "$WORK_DIR/base/hpa.yaml"
          
          if [[ "${{ env.INGRESS_ENABLED }}" == "true" ]]; then
            kubectl apply -f "$WORK_DIR/base/ingress.yaml"
          fi
      
      - name: Wait for deployment
        run: |
          echo "‚è≥ Waiting for deployment to be ready..."
          kubectl rollout status deployment/${{ env.APP_NAME }} -n ${{ env.NAMESPACE }} --timeout=300s
      
      - name: Display deployment status
        run: |
          echo ""
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "‚úÖ Kubernetes deployment completed successfully!"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo ""
          echo "üìä Deployment Status:"
          kubectl get deployments -n ${{ env.NAMESPACE }}
          echo ""
          echo "üîå Services:"
          kubectl get services -n ${{ env.NAMESPACE }}
          echo ""
          echo "üì¶ Pods:"
          kubectl get pods -n ${{ env.NAMESPACE }}
          echo ""
          echo "üåê Minikube Service URL:"
          minikube service ${{ env.APP_NAME }}-service -n ${{ env.NAMESPACE }} --url || true

  deploy-kubernetes-prod:
    name: Deploy Kubernetes Resources (EKS)
    runs-on: ubuntu-latest
    needs: [build-and-push-image, deploy-infrastructure-prod]
    if: |
      always() &&
      needs.validate-configuration.result == 'success' &&
      (needs.build-and-push-image.result == 'success' || needs.build-and-push-image.result == 'skipped') &&
      (needs.deploy-infrastructure-prod.result == 'success' || needs.deploy-infrastructure-prod.result == 'skipped') &&
      (github.event.inputs.deploy_target == 'prod' || vars.DEPLOY_TARGET == 'prod')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: latest
          terraform_wrapper: false
      
      - name: Get EKS cluster name from Terraform
        id: get_cluster
        working-directory: ./infra/terraform
        run: |
          terraform init -upgrade
          CLUSTER_NAME=$(terraform output -raw cluster_name 2>/dev/null || echo "devops-eks-cluster")
          echo "cluster_name=$CLUSTER_NAME" >> $GITHUB_OUTPUT
          echo "üì¶ EKS Cluster Name: $CLUSTER_NAME"
      
      - name: Configure kubectl for EKS
        run: |
          echo "‚öôÔ∏è  Configuring kubectl for EKS..."
          aws eks update-kubeconfig \
            --region ${{ env.AWS_REGION }} \
            --name ${{ steps.get_cluster.outputs.cluster_name }}
      
      - name: Verify cluster connectivity
        run: |
          echo "üîç Verifying cluster connectivity..."
          kubectl cluster-info
          kubectl get nodes
          echo "‚úÖ Successfully connected to Kubernetes cluster"
      
      - name: Install envsubst
        run: |
          sudo apt-get update
          sudo apt-get install -y gettext-base
      
      - name: Substitute environment variables in manifests
        run: |
          echo "üìù Processing Kubernetes manifests..."
          
          # Create temporary working directory
          WORK_DIR="/tmp/k8s-deployment-$$"
          mkdir -p "$WORK_DIR"
          
          # Copy manifests
          cp -r kubernetes/base "$WORK_DIR/"
          cp -r kubernetes/overlays "$WORK_DIR/"
          
          # Export all environment variables for envsubst
          export APP_NAME="${{ env.APP_NAME }}"
          export NAMESPACE="${{ env.NAMESPACE }}"
          export DOCKERHUB_USERNAME="${{ vars.DOCKERHUB_USERNAME }}"
          export DOCKER_IMAGE_TAG="${{ env.DOCKER_IMAGE_TAG }}"
          export APP_PORT="${{ env.APP_PORT }}"
          export REPLICAS="${{ env.REPLICAS }}"
          export MIN_REPLICAS="${{ env.MIN_REPLICAS }}"
          export MAX_REPLICAS="${{ env.MAX_REPLICAS }}"
          export CPU_TARGET_UTILIZATION="${{ env.CPU_TARGET_UTILIZATION }}"
          export MEMORY_TARGET_UTILIZATION="${{ env.MEMORY_TARGET_UTILIZATION }}"
          export APP_CPU_REQUEST="${{ env.APP_CPU_REQUEST }}"
          export APP_CPU_LIMIT="${{ env.APP_CPU_LIMIT }}"
          export APP_MEMORY_REQUEST="${{ env.APP_MEMORY_REQUEST }}"
          export APP_MEMORY_LIMIT="${{ env.APP_MEMORY_LIMIT }}"
          export DB_HOST="${{ secrets.DB_HOST }}"
          export DB_PORT="${{ secrets.DB_PORT }}"
          export DB_NAME="${{ secrets.DB_NAME }}"
          export DB_USERNAME="${{ secrets.DB_USERNAME }}"
          export DB_PASSWORD="${{ secrets.DB_PASSWORD }}"
          export JWT_SECRET="${{ secrets.JWT_SECRET }}"
          export API_KEY="${{ secrets.API_KEY }}"
          export SESSION_SECRET="${{ secrets.SESSION_SECRET }}"
          export INGRESS_HOST="${{ env.INGRESS_HOST }}"
          export INGRESS_CLASS="${{ env.INGRESS_CLASS }}"
          export TLS_SECRET_NAME="${{ env.TLS_SECRET_NAME }}"
          export PROMETHEUS_NAMESPACE="${{ env.PROMETHEUS_NAMESPACE }}"
          
          # Process all YAML files
          find "$WORK_DIR" -type f \( -name "*.yaml" -o -name "*.yml" \) | while read -r file; do
            echo "  Processing: $file"
            envsubst < "$file" > "${file}.tmp"
            mv "${file}.tmp" "$file"
          done
          
          # Save processed manifests for deployment
          echo "WORK_DIR=$WORK_DIR" >> $GITHUB_ENV
      
      - name: Create namespace
        run: |
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
      
      - name: Deploy base Kubernetes resources
        run: |
          echo "üîß Deploying base Kubernetes resources..."
          
          kubectl apply -f "$WORK_DIR/base/namespace.yaml" || true
          kubectl apply -f "$WORK_DIR/base/configmap.yaml"
          kubectl apply -f "$WORK_DIR/base/secrets.yaml"
          kubectl apply -f "$WORK_DIR/base/deployment.yaml"
          kubectl apply -f "$WORK_DIR/base/service.yaml"
          kubectl apply -f "$WORK_DIR/base/hpa.yaml"
          
          if [[ "${{ env.INGRESS_ENABLED }}" == "true" ]]; then
            kubectl apply -f "$WORK_DIR/base/ingress.yaml"
          fi
      
      - name: Wait for deployment
        run: |
          echo "‚è≥ Waiting for deployment to be ready..."
          kubectl rollout status deployment/${{ env.APP_NAME }} -n ${{ env.NAMESPACE }} --timeout=300s
      
      - name: Display deployment status
        run: |
          echo ""
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "‚úÖ Kubernetes deployment completed successfully!"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo ""
          echo "üìä Deployment Status:"
          kubectl get deployments -n ${{ env.NAMESPACE }}
          echo ""
          echo "üîå Services:"
          kubectl get services -n ${{ env.NAMESPACE }}
          echo ""
          echo "üì¶ Pods:"
          kubectl get pods -n ${{ env.NAMESPACE }}
          echo ""
          echo "üåê LoadBalancer Information:"
          echo "   Waiting for external IP to be assigned..."
          kubectl get svc ${{ env.APP_NAME }}-service -n ${{ env.NAMESPACE }}
          echo ""
          echo "üí° To get the LoadBalancer URL, run:"
          echo "   kubectl get svc ${{ env.APP_NAME }}-service -n ${{ env.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}'"

  deploy-monitoring-local:
    name: Deploy Monitoring Stack (Minikube)
    runs-on: ubuntu-latest
    needs: deploy-kubernetes-local
    if: |
      always() && 
      needs.deploy-kubernetes-local.result == 'success' && 
      (vars.PROMETHEUS_ENABLED == 'true' || vars.PROMETHEUS_ENABLED == '') &&
      (github.event.inputs.deploy_target == 'local' || vars.DEPLOY_TARGET == 'local')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Start Minikube
        uses: medyagh/setup-minikube@latest
        with:
          cpus: 2
          memory: 4096
          kubernetes-version: v1.28.0
          driver: docker
      
      - name: Enable Minikube addons
        run: |
          minikube addons enable ingress
          minikube addons enable metrics-server
      
      - name: Verify Minikube connection
        run: |
          kubectl cluster-info
          kubectl get nodes
      
      - name: Install envsubst
        run: |
          sudo apt-get update
          sudo apt-get install -y gettext-base
      
      - name: Process monitoring manifests
        run: |
          echo "üìù Processing monitoring manifests..."
          
          WORK_DIR="/tmp/monitoring-deployment-$$"
          mkdir -p "$WORK_DIR/monitoring" "$WORK_DIR/prometheus"
          
          cp -r monitoring/prometheus_grafana/* "$WORK_DIR/monitoring/"
          cp -r monitoring/prometheus/* "$WORK_DIR/prometheus/" 2>/dev/null || true
          cp -r monitoring/kube-state-metrics "$WORK_DIR/monitoring/" 2>/dev/null || true
          
          # Export monitoring variables
          export APP_NAME="${{ env.APP_NAME }}"
          export NAMESPACE="${{ env.NAMESPACE }}"
          export PROMETHEUS_NAMESPACE="${{ env.PROMETHEUS_NAMESPACE }}"
          export PROMETHEUS_SCRAPE_INTERVAL="${{ env.PROMETHEUS_SCRAPE_INTERVAL }}"
          export PROMETHEUS_SCRAPE_TIMEOUT="${{ env.PROMETHEUS_SCRAPE_TIMEOUT }}"
          export PROMETHEUS_CPU_REQUEST="${{ env.PROMETHEUS_CPU_REQUEST }}"
          export PROMETHEUS_CPU_LIMIT="${{ env.PROMETHEUS_CPU_LIMIT }}"
          export PROMETHEUS_MEMORY_REQUEST="${{ env.PROMETHEUS_MEMORY_REQUEST }}"
          export PROMETHEUS_MEMORY_LIMIT="${{ env.PROMETHEUS_MEMORY_LIMIT }}"
          export PROMETHEUS_RETENTION="${{ env.PROMETHEUS_RETENTION }}"
          export PROMETHEUS_STORAGE_SIZE="${{ env.PROMETHEUS_STORAGE_SIZE }}"
          export GRAFANA_CPU_REQUEST="${{ env.GRAFANA_CPU_REQUEST }}"
          export GRAFANA_CPU_LIMIT="${{ env.GRAFANA_CPU_LIMIT }}"
          export GRAFANA_MEMORY_REQUEST="${{ env.GRAFANA_MEMORY_REQUEST }}"
          export GRAFANA_MEMORY_LIMIT="${{ env.GRAFANA_MEMORY_LIMIT }}"
          export GRAFANA_STORAGE_SIZE="${{ env.GRAFANA_STORAGE_SIZE }}"
          export GRAFANA_ADMIN_USER="${{ env.GRAFANA_ADMIN_USER }}"
          export GRAFANA_ADMIN_PASSWORD="${{ secrets.GRAFANA_ADMIN_PASSWORD }}"
          export DEPLOY_TARGET="${{ env.DEPLOY_TARGET }}"
          
          # Process YAML files
          find "$WORK_DIR" -type f \( -name "*.yaml" -o -name "*.yml" \) | while read -r file; do
            echo "  Processing: $file"
            envsubst < "$file" > "${file}.tmp"
            mv "${file}.tmp" "$file"
          done
          
          echo "MONITORING_WORK_DIR=$WORK_DIR" >> $GITHUB_ENV
      
      - name: Create monitoring namespace
        run: |
          kubectl create namespace ${{ env.PROMETHEUS_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
      
      - name: Create Prometheus ConfigMap
        run: |
          if [[ -f "$MONITORING_WORK_DIR/prometheus/prometheus.yml" ]]; then
            kubectl create configmap prometheus-config \
              --from-file=prometheus.yml="$MONITORING_WORK_DIR/prometheus/prometheus.yml" \
              -n ${{ env.PROMETHEUS_NAMESPACE }} \
              --dry-run=client -o yaml | kubectl apply -f -
          fi
          
          if [[ -f "$MONITORING_WORK_DIR/prometheus/alerts.yml" ]]; then
            kubectl create configmap prometheus-alerts \
              --from-file=alerts.yml="$MONITORING_WORK_DIR/prometheus/alerts.yml" \
              -n ${{ env.PROMETHEUS_NAMESPACE }} \
              --dry-run=client -o yaml | kubectl apply -f -
          fi
      
      - name: Deploy Prometheus
        run: |
          echo "üîç Deploying Prometheus..."
          kubectl apply -f "$MONITORING_WORK_DIR/monitoring/prometheus.yaml"
          
          if [[ -d "$MONITORING_WORK_DIR/monitoring/kube-state-metrics" ]]; then
            kubectl apply -f "$MONITORING_WORK_DIR/monitoring/kube-state-metrics/"
          fi
      
      - name: Wait for Prometheus
        run: |
          kubectl rollout status deployment/prometheus -n ${{ env.PROMETHEUS_NAMESPACE }} --timeout=300s
      
      - name: Deploy Grafana
        if: ${{ env.GRAFANA_ENABLED == 'true' }}
        run: |
          echo "üìà Deploying Grafana..."
          
          if [[ -f "$MONITORING_WORK_DIR/monitoring/grafana.yaml" ]]; then
            kubectl apply -f "$MONITORING_WORK_DIR/monitoring/grafana.yaml"
          fi
          
          if [[ -f "$MONITORING_WORK_DIR/monitoring/dashboard-configmap.yaml" ]]; then
            kubectl apply -f "$MONITORING_WORK_DIR/monitoring/dashboard-configmap.yaml"
          fi
      
      - name: Wait for Grafana
        if: ${{ env.GRAFANA_ENABLED == 'true' }}
        run: |
          kubectl rollout status deployment/grafana -n ${{ env.PROMETHEUS_NAMESPACE }} --timeout=300s
      
      - name: Display monitoring status
        run: |
          echo ""
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "‚úÖ Monitoring stack deployed successfully on Minikube!"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo ""
          echo "üìä Monitoring Components:"
          kubectl get all -n ${{ env.PROMETHEUS_NAMESPACE }}
          echo ""
          echo "üåê Prometheus URL:"
          minikube service prometheus -n ${{ env.PROMETHEUS_NAMESPACE }} --url || true
          echo ""
          echo "üìà Grafana URL:"
          minikube service grafana -n ${{ env.PROMETHEUS_NAMESPACE }} --url || true

  deploy-monitoring-prod:
    name: Deploy Monitoring Stack (EKS)
    runs-on: ubuntu-latest
    needs: deploy-kubernetes-prod
    if: |
      always() && 
      needs.deploy-kubernetes-prod.result == 'success' && 
      (vars.PROMETHEUS_ENABLED == 'true' || vars.PROMETHEUS_ENABLED == '') &&
      (github.event.inputs.deploy_target == 'prod' || vars.DEPLOY_TARGET == 'prod')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: latest
          terraform_wrapper: false
      
      - name: Get EKS cluster name from Terraform
        id: get_cluster
        working-directory: ./infra/terraform
        run: |
          terraform init -upgrade
          CLUSTER_NAME=$(terraform output -raw cluster_name 2>/dev/null || echo "devops-eks-cluster")
          echo "cluster_name=$CLUSTER_NAME" >> $GITHUB_OUTPUT
      
      - name: Configure kubectl for EKS
        run: |
          aws eks update-kubeconfig \
            --region ${{ env.AWS_REGION }} \
            --name ${{ steps.get_cluster.outputs.cluster_name }}
      
      - name: Install envsubst
        run: |
          sudo apt-get update
          sudo apt-get install -y gettext-base
      
      - name: Process monitoring manifests
        run: |
          echo "üìù Processing monitoring manifests..."
          
          WORK_DIR="/tmp/monitoring-deployment-$$"
          mkdir -p "$WORK_DIR/monitoring" "$WORK_DIR/prometheus"
          
          cp -r monitoring/prometheus_grafana/* "$WORK_DIR/monitoring/"
          cp -r monitoring/prometheus/* "$WORK_DIR/prometheus/" 2>/dev/null || true
          cp -r monitoring/kube-state-metrics "$WORK_DIR/monitoring/" 2>/dev/null || true
          
          # Export monitoring variables
          export APP_NAME="${{ env.APP_NAME }}"
          export NAMESPACE="${{ env.NAMESPACE }}"
          export PROMETHEUS_NAMESPACE="${{ env.PROMETHEUS_NAMESPACE }}"
          export PROMETHEUS_SCRAPE_INTERVAL="${{ env.PROMETHEUS_SCRAPE_INTERVAL }}"
          export PROMETHEUS_SCRAPE_TIMEOUT="${{ env.PROMETHEUS_SCRAPE_TIMEOUT }}"
          export PROMETHEUS_CPU_REQUEST="${{ env.PROMETHEUS_CPU_REQUEST }}"
          export PROMETHEUS_CPU_LIMIT="${{ env.PROMETHEUS_CPU_LIMIT }}"
          export PROMETHEUS_MEMORY_REQUEST="${{ env.PROMETHEUS_MEMORY_REQUEST }}"
          export PROMETHEUS_MEMORY_LIMIT="${{ env.PROMETHEUS_MEMORY_LIMIT }}"
          export PROMETHEUS_RETENTION="${{ env.PROMETHEUS_RETENTION }}"
          export PROMETHEUS_STORAGE_SIZE="${{ env.PROMETHEUS_STORAGE_SIZE }}"
          export GRAFANA_CPU_REQUEST="${{ env.GRAFANA_CPU_REQUEST }}"
          export GRAFANA_CPU_LIMIT="${{ env.GRAFANA_CPU_LIMIT }}"
          export GRAFANA_MEMORY_REQUEST="${{ env.GRAFANA_MEMORY_REQUEST }}"
          export GRAFANA_MEMORY_LIMIT="${{ env.GRAFANA_MEMORY_LIMIT }}"
          export GRAFANA_STORAGE_SIZE="${{ env.GRAFANA_STORAGE_SIZE }}"
          export GRAFANA_ADMIN_USER="${{ env.GRAFANA_ADMIN_USER }}"
          export GRAFANA_ADMIN_PASSWORD="${{ secrets.GRAFANA_ADMIN_PASSWORD }}"
          export DEPLOY_TARGET="${{ env.DEPLOY_TARGET }}"
          
          # Process YAML files
          find "$WORK_DIR" -type f \( -name "*.yaml" -o -name "*.yml" \) | while read -r file; do
            echo "  Processing: $file"
            envsubst < "$file" > "${file}.tmp"
            mv "${file}.tmp" "$file"
          done
          
          echo "MONITORING_WORK_DIR=$WORK_DIR" >> $GITHUB_ENV
      
      - name: Create monitoring namespace
        run: |
          kubectl create namespace ${{ env.PROMETHEUS_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
      
      - name: Create Prometheus ConfigMap
        run: |
          if [[ -f "$MONITORING_WORK_DIR/prometheus/prometheus.yml" ]]; then
            kubectl create configmap prometheus-config \
              --from-file=prometheus.yml="$MONITORING_WORK_DIR/prometheus/prometheus.yml" \
              -n ${{ env.PROMETHEUS_NAMESPACE }} \
              --dry-run=client -o yaml | kubectl apply -f -
          fi
          
          if [[ -f "$MONITORING_WORK_DIR/prometheus/alerts.yml" ]]; then
            kubectl create configmap prometheus-alerts \
              --from-file=alerts.yml="$MONITORING_WORK_DIR/prometheus/alerts.yml" \
              -n ${{ env.PROMETHEUS_NAMESPACE }} \
              --dry-run=client -o yaml | kubectl apply -f -
          fi
      
      - name: Deploy Prometheus
        run: |
          echo "üîç Deploying Prometheus..."
          kubectl apply -f "$MONITORING_WORK_DIR/monitoring/prometheus.yaml"
          
          if [[ -d "$MONITORING_WORK_DIR/monitoring/kube-state-metrics" ]]; then
            kubectl apply -f "$MONITORING_WORK_DIR/monitoring/kube-state-metrics/"
          fi
      
      - name: Wait for Prometheus
        run: |
          kubectl rollout status deployment/prometheus -n ${{ env.PROMETHEUS_NAMESPACE }} --timeout=300s
      
      - name: Deploy Grafana
        if: ${{ env.GRAFANA_ENABLED == 'true' }}
        run: |
          echo "üìà Deploying Grafana..."
          
          if [[ -f "$MONITORING_WORK_DIR/monitoring/grafana.yaml" ]]; then
            kubectl apply -f "$MONITORING_WORK_DIR/monitoring/grafana.yaml"
          fi
          
          if [[ -f "$MONITORING_WORK_DIR/monitoring/dashboard-configmap.yaml" ]]; then
            kubectl apply -f "$MONITORING_WORK_DIR/monitoring/dashboard-configmap.yaml"
          fi
      
      - name: Wait for Grafana
        if: ${{ env.GRAFANA_ENABLED == 'true' }}
        run: |
          kubectl rollout status deployment/grafana -n ${{ env.PROMETHEUS_NAMESPACE }} --timeout=300s
      
      - name: Display monitoring status
        run: |
          echo ""
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "‚úÖ Monitoring stack deployed successfully!"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo ""
          echo "üìä Monitoring Components:"
          kubectl get all -n ${{ env.PROMETHEUS_NAMESPACE }}
          echo ""

  deployment-summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [deploy-kubernetes-local, deploy-kubernetes-prod, deploy-monitoring-local, deploy-monitoring-prod]
    if: always()
    
    steps:
      - name: Generate deployment summary
        run: |
          echo "# DevOps Project Deployment Summary üöÄ" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Configuration" >> $GITHUB_STEP_SUMMARY
          echo "- **Target**: ${{ env.DEPLOY_TARGET }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Application**: ${{ env.APP_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Namespace**: ${{ env.NAMESPACE }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Tag**: ${{ env.DOCKER_IMAGE_TAG }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Job Status" >> $GITHUB_STEP_SUMMARY
          echo "- Build & Push: ${{ needs.build-and-push-image.result || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ env.DEPLOY_TARGET }}" == "local" ]]; then
            echo "- Minikube Setup: ${{ needs.setup-minikube.result || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
            echo "- Kubernetes (Minikube): ${{ needs.deploy-kubernetes-local.result || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
            echo "- Monitoring (Minikube): ${{ needs.deploy-monitoring-local.result || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "- Infrastructure (AWS): ${{ needs.deploy-infrastructure-prod.result || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
            echo "- Kubernetes (EKS): ${{ needs.deploy-kubernetes-prod.result || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
            echo "- Monitoring (EKS): ${{ needs.deploy-monitoring-prod.result || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ needs.deploy-kubernetes-local.result }}" == "success" ]] || [[ "${{ needs.deploy-kubernetes-prod.result }}" == "success" ]]; then
            echo "‚úÖ Deployment completed successfully!" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå Deployment encountered issues. Check job logs for details." >> $GITHUB_STEP_SUMMARY
          fi