# ============================================================================
# GitHub Actions Workflow for DevOps Project
# ============================================================================
# Configure secrets in: Repository â†’ Settings â†’ Secrets and variables â†’ Actions
# Required Secrets: See dotenv_example for complete list
# ============================================================================

name: DevOps Deployment Pipeline

on:
  push:
    branches:
      - main
      - develop
      - 'feature/**'
  pull_request:
    branches:
      - main
      - develop
  workflow_dispatch:
    inputs:
      deploy_target:
        description: 'Deployment target'
        required: true
        default: 'local'
        type: choice
        options:
          - local
          - prod
      dry_run:
        description: 'Dry run mode (no actual deployment)'
        required: false
        default: false
        type: boolean

env:
  # Project Configuration
  APP_NAME: ${{ vars.APP_NAME || 'devops-app' }}
  NAMESPACE: ${{ vars.NAMESPACE || 'devops-app' }}
  APP_PORT: ${{ vars.APP_PORT || '3000' }}
  REPLICAS: ${{ vars.REPLICAS || '2' }}
  MIN_REPLICAS: ${{ vars.MIN_REPLICAS || '2' }}
  MAX_REPLICAS: ${{ vars.MAX_REPLICAS || '10' }}
  CPU_TARGET_UTILIZATION: ${{ vars.CPU_TARGET_UTILIZATION || '70' }}
  MEMORY_TARGET_UTILIZATION: ${{ vars.MEMORY_TARGET_UTILIZATION || '80' }}
  
  # Docker Configuration
  DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
  DOCKER_IMAGE_TAG: ${{ vars.DOCKER_IMAGE_TAG || 'latest' }}
  IMAGE_TAG: ${{ vars.IMAGE_TAG || 'latest' }}
  
  # Ingress Configuration
  INGRESS_ENABLED: ${{ vars.INGRESS_ENABLED || 'true' }}
  INGRESS_HOST: ${{ vars.INGRESS_HOST || 'devops-app.local' }}
  INGRESS_CLASS: ${{ vars.INGRESS_CLASS || 'nginx' }}
  TLS_ENABLED: ${{ vars.TLS_ENABLED || 'false' }}
  TLS_SECRET_NAME: ${{ vars.TLS_SECRET_NAME || 'devops-app-tls' }}
  
  # Database Configuration
  DB_HOST: ${{ vars.DB_HOST || 'localhost' }}
  DB_PORT: ${{ vars.DB_PORT || '5432' }}
  DB_NAME: ${{ vars.DB_NAME || 'devopsdb' }}
  DB_USERNAME: ${{ secrets.DB_USERNAME || 'dbuser' }}
  
  # Monitoring - Prometheus
  PROMETHEUS_ENABLED: ${{ vars.PROMETHEUS_ENABLED || 'true' }}
  PROMETHEUS_NAMESPACE: ${{ vars.PROMETHEUS_NAMESPACE || 'monitoring' }}
  PROMETHEUS_RETENTION: ${{ vars.PROMETHEUS_RETENTION || '15d' }}
  PROMETHEUS_STORAGE_SIZE: ${{ vars.PROMETHEUS_STORAGE_SIZE || '10Gi' }}
  PROMETHEUS_SCRAPE_INTERVAL: ${{ vars.PROMETHEUS_SCRAPE_INTERVAL || '15s' }}
  PROMETHEUS_SCRAPE_TIMEOUT: ${{ vars.PROMETHEUS_SCRAPE_TIMEOUT || '10s' }}
  
  # Monitoring - Grafana
  GRAFANA_ENABLED: ${{ vars.GRAFANA_ENABLED || 'true' }}
  GRAFANA_ADMIN_USER: ${{ vars.GRAFANA_ADMIN_USER || 'admin' }}
  GRAFANA_PORT: ${{ vars.GRAFANA_PORT || '3000' }}
  GRAFANA_STORAGE_SIZE: ${{ vars.GRAFANA_STORAGE_SIZE || '5Gi' }}
  
  # Alerting Configuration
  ALERT_EMAIL_ENABLED: ${{ vars.ALERT_EMAIL_ENABLED || 'false' }}
  SMTP_HOST: ${{ vars.SMTP_HOST || 'smtp.gmail.com' }}
  SMTP_PORT: ${{ vars.SMTP_PORT || '587' }}
  
  # Resource Limits - Application
  APP_CPU_REQUEST: ${{ vars.APP_CPU_REQUEST || '100m' }}
  APP_CPU_LIMIT: ${{ vars.APP_CPU_LIMIT || '500m' }}
  APP_MEMORY_REQUEST: ${{ vars.APP_MEMORY_REQUEST || '128Mi' }}
  APP_MEMORY_LIMIT: ${{ vars.APP_MEMORY_LIMIT || '512Mi' }}
  
  # Resource Limits - Prometheus
  PROMETHEUS_CPU_REQUEST: ${{ vars.PROMETHEUS_CPU_REQUEST || '500m' }}
  PROMETHEUS_CPU_LIMIT: ${{ vars.PROMETHEUS_CPU_LIMIT || '2000m' }}
  PROMETHEUS_MEMORY_REQUEST: ${{ vars.PROMETHEUS_MEMORY_REQUEST || '1Gi' }}
  PROMETHEUS_MEMORY_LIMIT: ${{ vars.PROMETHEUS_MEMORY_LIMIT || '4Gi' }}
  
  # Resource Limits - Grafana
  GRAFANA_CPU_REQUEST: ${{ vars.GRAFANA_CPU_REQUEST || '100m' }}
  GRAFANA_CPU_LIMIT: ${{ vars.GRAFANA_CPU_LIMIT || '500m' }}
  GRAFANA_MEMORY_REQUEST: ${{ vars.GRAFANA_MEMORY_REQUEST || '256Mi' }}
  GRAFANA_MEMORY_LIMIT: ${{ vars.GRAFANA_MEMORY_LIMIT || '1Gi' }}
  
  # AWS Configuration
  AWS_REGION: ${{ vars.AWS_REGION || 'us-east-1' }}
  AWS_ACCOUNT_ID: ${{ vars.AWS_ACCOUNT_ID }}
  EKS_CLUSTER_NAME: ${{ vars.EKS_CLUSTER_NAME || 'devops-cluster' }}
  
  # Git Configuration
  GIT_AUTHOR_NAME: ${{ vars.GIT_AUTHOR_NAME || github.actor }}
  GIT_AUTHOR_EMAIL: ${{ vars.GIT_AUTHOR_EMAIL || format('{0}@users.noreply.github.com', github.actor) }}
  GITHUB_USERNAME: ${{ github.actor }}
  GITHUB_EMAIL: ${{ vars.GITHUB_EMAIL || format('{0}@users.noreply.github.com', github.actor) }}
  
  # Deployment Configuration
  DEPLOY_TARGET: ${{ github.event.inputs.deploy_target || vars.DEPLOY_TARGET || 'local' }}
  BUILD_PUSH: ${{ vars.BUILD_PUSH || 'true' }}
  CI: true
  DRY_RUN: ${{ github.event.inputs.dry_run || vars.DRY_RUN || 'false' }}

jobs:
  # VALIDATION JOBS  
  validate-variables:
    name: Validate CI/CD Variables
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Validate required variables
        run: |
          echo "============================================================================"
          echo "Validating Required CI/CD Variables"
          echo "============================================================================"
          
          REQUIRED_VARS=(
            "APP_NAME"
            "NAMESPACE"
            "DOCKERHUB_USERNAME"
            "DOCKER_IMAGE_TAG"
            "APP_PORT"
            "REPLICAS"
            "DEPLOY_TARGET"
          )
          
          MISSING_VARS=()
          
          for var in "${REQUIRED_VARS[@]}"; do
            if [ -z "${!var}" ]; then
              MISSING_VARS+=("$var")
            fi
          done
          
          if [ ${#MISSING_VARS[@]} -gt 0 ]; then
            echo "âŒ Missing required variables:"
            for var in "${MISSING_VARS[@]}"; do
              echo "   - $var"
            done
            echo ""
            echo "Configure these in: Settings â†’ Secrets and variables â†’ Actions"
            exit 1
          else
            echo "âœ… All required variables are present"
          fi
      
      - name: Validate secret variables
        run: |
          echo ""
          echo "Checking secret variables (values will not be displayed)..."
          
          if [ -z "${{ secrets.DOCKERHUB_PASSWORD }}" ]; then
            echo "âš ï¸  Warning: DOCKERHUB_PASSWORD is not set"
          else
            echo "âœ… DOCKERHUB_PASSWORD is configured"
          fi
          
          if [ -z "${{ secrets.DB_PASSWORD }}" ]; then
            echo "âš ï¸  Warning: DB_PASSWORD is not set"
          else
            echo "âœ… DB_PASSWORD is configured"
          fi
          
          if [ -z "${{ secrets.JWT_SECRET }}" ]; then
            echo "âš ï¸  Warning: JWT_SECRET is not set"
          else
            echo "âœ… JWT_SECRET is configured"
          fi
          
          if [ -z "${{ secrets.API_KEY }}" ]; then
            echo "âš ï¸  Warning: API_KEY is not set"
          else
            echo "âœ… API_KEY is configured"
          fi
  
  validate-tools:
    name: Validate Required Tools
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Check tool versions
        run: |
          echo "============================================================================"
          echo "Checking Tool Versions"
          echo "============================================================================"
          docker --version || true
          kubectl version --client || true
          git --version || true
          echo ""
          echo "âœ… All required tools are available"

  # BUILD JOBS  
  build-docker-image:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: [validate-variables, validate-tools]
    if: vars.BUILD_PUSH == 'true' || vars.BUILD_PUSH == ''
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}
      
      - name: Build and push Docker image
        run: |
          echo "============================================================================"
          echo "Building and Pushing Docker Image"
          echo "============================================================================"
          
          export PROJECT_ROOT=${{ github.workspace }}
          
          # Source the build script
          source "${{ github.workspace }}/app/build_and_push_image.sh"
          
          # Execute build and push
          build_and_push_image
          
          echo ""
          echo "âœ… Docker image built and pushed successfully"
          echo "   Image: $DOCKERHUB_USERNAME/$APP_NAME:$DOCKER_IMAGE_TAG"
  
  build-docker-image-local:
    name: Build Docker Image (Local Only)
    runs-on: ubuntu-latest
    needs: [validate-variables, validate-tools]
    if: vars.BUILD_PUSH == 'false'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Build Docker image
        run: |
          echo "============================================================================"
          echo "Building Docker Image (Local Only - No Push)"
          echo "============================================================================"
          
          cd "${{ github.workspace }}/app"
          docker build -t "$APP_NAME:latest" .
          
          echo ""
          echo "âœ… Docker image built successfully (not pushed)"

  # DEPLOY LOCAL JOBS  
  deploy-local:
    name: Deploy to Local Kubernetes
    runs-on: ubuntu-latest
    needs: [build-docker-image, build-docker-image-local]
    if: |
      always() && 
      !cancelled() && 
      (needs.build-docker-image.result == 'success' || needs.build-docker-image-local.result == 'success') &&
      (vars.DEPLOY_TARGET == 'local' || github.event.inputs.deploy_target == 'local')
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'
      
      - name: Configure kubectl
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBECONFIG_PROD }}" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
          kubectl config use-context "${{ vars.KUBE_CONTEXT }}" || true
      
      - name: Detect and deploy to Kubernetes cluster
        env:
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          API_KEY: ${{ secrets.API_KEY }}
          SESSION_SECRET: ${{ secrets.SESSION_SECRET }}
          GRAFANA_ADMIN_PASSWORD: ${{ secrets.GRAFANA_ADMIN_PASSWORD }}
          ALERT_EMAIL_TO: ${{ vars.ALERT_EMAIL_TO }}
          ALERT_EMAIL_FROM: ${{ vars.ALERT_EMAIL_FROM }}
          SMTP_USERNAME: ${{ secrets.SMTP_USERNAME }}
          SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          echo "============================================================================"
          echo "Deploying to Local Kubernetes Environment"
          echo "============================================================================"

          export PROJECT_ROOT=${{ github.workspace }}

          # Skip local Kubernetes deploy in CI
          if [[ "${CI:-false}" == "true" && "${DEPLOY_TARGET:-local}" == "local" ]]; then
            echo "âš ï¸  Skipping local Kubernetes deployment in CI"
            echo "    Local clusters are not available on GitHub Actions runners"
            exit 0
          fi

          echo "ðŸ” Detecting Kubernetes cluster..."
          if ! kubectl cluster-info >/dev/null 2>&1; then
            echo "âŒ Cannot connect to Kubernetes cluster"
            exit 1
          fi

          # Detect distribution
          CONTEXT=$(kubectl config current-context 2>/dev/null || echo "")
          K8S_DIST="unknown"
          if kubectl get nodes -o json 2>/dev/null | grep -q '"minikube.k8s.io/version"'; then
            K8S_DIST="minikube"
          elif [[ "$CONTEXT" == *"kind"* ]] || kubectl get nodes -o json 2>/dev/null | grep -q "kind-control-plane"; then
            K8S_DIST="kind"
          elif kubectl get nodes -o json 2>/dev/null | grep -q '"k3s.io"'; then
            K8S_DIST="k3s"
          elif kubectl get nodes -o json 2>/dev/null | grep -q '"microk8s.io"'; then
            K8S_DIST="microk8s"
          else
            K8S_DIST="kubernetes"
          fi

          export K8S_DISTRIBUTION="$K8S_DIST"
          export K8S_CONTEXT="$CONTEXT"

          echo "âœ… Connected to: $K8S_DIST"
          echo "   Context: $CONTEXT"

      
      - name: Display deployment info
        if: always()
        run: |
          echo ""
          echo "============================================================================"
          echo "Deployment Information"
          echo "============================================================================"
          kubectl get pods -n $NAMESPACE || true
          kubectl get svc -n $NAMESPACE || true
          kubectl get ingress -n $NAMESPACE || true

  # DEPLOY PRODUCTION JOBS  
  deploy-terraform-infrastructure:
    name: Deploy Infrastructure (Terraform)
    runs-on: ubuntu-latest
    needs: [build-docker-image]
    if: |
      always() && 
      !cancelled() && 
      needs.build-docker-image.result == 'success' &&
      (vars.DEPLOY_TARGET == 'prod' || github.event.inputs.deploy_target == 'prod') &&
      (vars.K8S_DISTRIBUTION == 'eks' || vars.K8S_DISTRIBUTION == '')
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Deploy infrastructure with Terraform
        working-directory: infra/terraform
        run: |
          echo "============================================================================"
          echo "Deploying Infrastructure with Terraform"
          echo "============================================================================"
          
          terraform init -upgrade
          terraform validate
          terraform plan -out=tfplan
          
          if [ "$DRY_RUN" == "true" ]; then
            echo "ðŸ” DRY RUN MODE - Skipping apply"
          else
            terraform apply -auto-approve tfplan
            
            # Update kubeconfig for EKS
            REGION=$(terraform output -raw region)
            CLUSTER_NAME=$(terraform output -raw cluster_name)
            
            aws eks update-kubeconfig \
              --region "$REGION" \
              --name "$CLUSTER_NAME"
          fi
      
      - name: Upload Terraform artifacts
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan
          path: |
            infra/terraform/tfplan
            infra/terraform/.terraform/
          retention-days: 1
  
  deploy-production:
    name: Deploy to Production Kubernetes
    runs-on: ubuntu-latest
    needs: [deploy-terraform-infrastructure]
    if: |
      always() && 
      !cancelled() && 
      needs.deploy-terraform-infrastructure.result == 'success' &&
      (vars.DEPLOY_TARGET == 'prod' || github.event.inputs.deploy_target == 'prod')
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Configure kubectl for EKS
        run: |
          aws eks update-kubeconfig \
            --region "$AWS_REGION" \
            --name "$EKS_CLUSTER_NAME"
      
      - name: Deploy to production cluster
        env:
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          API_KEY: ${{ secrets.API_KEY }}
          SESSION_SECRET: ${{ secrets.SESSION_SECRET }}
          GRAFANA_ADMIN_PASSWORD: ${{ secrets.GRAFANA_ADMIN_PASSWORD }}
          ALERT_EMAIL_TO: ${{ vars.ALERT_EMAIL_TO }}
          ALERT_EMAIL_FROM: ${{ vars.ALERT_EMAIL_FROM }}
          SMTP_USERNAME: ${{ secrets.SMTP_USERNAME }}
          SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          echo "============================================================================"
          echo "Deploying to Production Kubernetes (Cloud)"
          echo "============================================================================"
          
          export PROJECT_ROOT=${{ github.workspace }}
          
          # Detect Kubernetes cluster
          echo ""
          echo "ðŸ” Detecting Kubernetes cluster..."
          
          if ! kubectl cluster-info >/dev/null 2>&1; then
            echo "âŒ Cannot connect to Kubernetes cluster"
            exit 1
          fi
          
          K8S_DIST="unknown"
          
          if kubectl get nodes -o json 2>/dev/null | grep -q '"eks.amazonaws.com"'; then
            K8S_DIST="eks"
          elif kubectl get nodes -o json 2>/dev/null | grep -q '"cloud.google.com/gke"'; then
            K8S_DIST="gke"
          elif kubectl get nodes -o json 2>/dev/null | grep -q '"kubernetes.azure.com"'; then
            K8S_DIST="aks"
          else
            K8S_DIST="kubernetes"
          fi
          
          export K8S_DISTRIBUTION="$K8S_DIST"
          
          echo "âœ… Connected to: $K8S_DIST"
          
          # Configure Git
          echo ""
          echo "âš™ï¸  Configuring Git..."
          source "${{ github.workspace }}/cicd/github/configure_git_github.sh"
          configure_git_github
          
          # Deploy Kubernetes resources
          echo ""
          echo "ðŸ“¦ Deploying Kubernetes resources..."
          source "${{ github.workspace }}/kubernetes/deploy_kubernetes.sh"
          deploy_kubernetes prod
          
          echo ""
          echo "âœ… Application deployed to $K8S_DIST"
          echo ""
          echo "â„¹ï¸  Check LoadBalancer or Ingress for external access:"
          kubectl get svc -n "$NAMESPACE"
          kubectl get ingress -n "$NAMESPACE"
      
      - name: Display deployment info
        if: always()
        run: |
          echo ""
          echo "============================================================================"
          echo "Production Deployment Information"
          echo "============================================================================"
          kubectl get pods -n $NAMESPACE || true
          kubectl get svc -n $NAMESPACE || true
          kubectl get ingress -n $NAMESPACE || true

  # MONITORING JOBS  
  deploy-monitoring:
    name: Deploy Monitoring Stack
    runs-on: ubuntu-latest
    needs: [deploy-local, deploy-production]
    if: |
      always() && 
      !cancelled() && 
      (needs.deploy-local.result == 'success' || needs.deploy-production.result == 'success') &&
      (vars.PROMETHEUS_ENABLED == 'true' || vars.PROMETHEUS_ENABLED == '')
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Set up Kind (Kubernetes in Docker)
        uses: engineerd/setup-kind@v0.5.0
        with:
          version: v0.20.0

      - name: Create Kind cluster
        run: |
          kind create cluster --name devops-ci --wait 60s
          kubectl cluster-info

      - name: Build Docker image locally for Kind
        run: |
          docker build -t "$APP_NAME:$IMAGE_TAG" ./app

      - name: Load Docker image into Kind
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          APP_NAME: ${{ env.APP_NAME }}
        run: |
          kind load docker-image "$APP_NAME:$IMAGE_TAG" --name devops-ci

      - name: Configure kubectl
        run: |
          mkdir -p $HOME/.kube
          
          if [ "$DEPLOY_TARGET" == "prod" ]; then
            # Configure AWS and kubectl for EKS
            echo "${{ secrets.AWS_ACCESS_KEY_ID }}" > /dev/null
            echo "${{ secrets.AWS_SECRET_ACCESS_KEY }}" > /dev/null
            
            # This would use AWS CLI to configure kubectl
            # aws eks update-kubeconfig --region "$AWS_REGION" --name "$EKS_CLUSTER_NAME"
            
            echo "Note: AWS CLI configuration would be done here for production"
          else
            echo "${{ secrets.KUBECONFIG_PROD }}" | base64 -d > $HOME/.kube/config
            chmod 600 $HOME/.kube/config
            kubectl config use-context "${{ vars.KUBE_CONTEXT }}" || true
          fi

      - name: Deploy application to Kind
        run: |
          source ./kubernetes/deploy_kubernetes.sh
          deploy_kubernetes local

      - name: Deploy monitoring stack
        env:
          GRAFANA_ADMIN_PASSWORD: ${{ secrets.GRAFANA_ADMIN_PASSWORD }}
          ALERT_EMAIL_TO: ${{ vars.ALERT_EMAIL_TO }}
          ALERT_EMAIL_FROM: ${{ vars.ALERT_EMAIL_FROM }}
          SMTP_USERNAME: ${{ secrets.SMTP_USERNAME }}
          SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          echo "============================================================================"
          echo "Deploying Monitoring Stack (Prometheus + Grafana)"
          echo "============================================================================"
          
          export PROJECT_ROOT=${{ github.workspace }}
          
          source "${{ github.workspace }}/monitoring/deploy_monitoring.sh"
          deploy_monitoring
          
          echo ""
          echo "âœ… Monitoring stack deployed successfully"
      
      - name: Display monitoring info
        if: always()
        run: |
          echo ""
          echo "============================================================================"
          echo "Monitoring Stack Information"
          echo "============================================================================"
          kubectl get pods -n $PROMETHEUS_NAMESPACE || true
          kubectl get svc -n $PROMETHEUS_NAMESPACE || true

      - name: Delete Kind cluster
        if: always()
        run: kind delete cluster --name devops-ci

  # CLEANUP JOBS  
  cleanup-on-failure:
    name: Cleanup on Failure
    runs-on: ubuntu-latest
    needs: [deploy-local, deploy-production]
    if: |
      failure() &&
      vars.AUTO_CLEANUP_ON_FAILURE == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'
      
      - name: Configure kubectl
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBECONFIG_PROD }}" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
          kubectl config use-context "${{ vars.KUBE_CONTEXT }}" || true
      
      - name: Cleanup resources
        run: |
          echo "============================================================================"
          echo "Cleaning up Failed Deployment"
          echo "============================================================================"
          
          kubectl delete namespace "$NAMESPACE" --ignore-not-found=true
          kubectl delete namespace "$PROMETHEUS_NAMESPACE" --ignore-not-found=true
          
          echo "âœ… Cleanup completed"