name: Production Deployment

on:
  push:
    branches:
      - main
      - production
  workflow_dispatch:
    inputs:
      deploy_target:
        description: 'Deployment target (local/prod)'
        required: true
        default: 'prod'
        type: choice
        options:
          - local
          - prod

env:
  # Project Configuration
  APP_NAME: ${{ secrets.APP_NAME || 'devops-app' }}
  NAMESPACE: ${{ secrets.NAMESPACE || 'devops-app' }}
  APP_PORT: ${{ vars.APP_PORT || '3000' }}
  REPLICAS: ${{ vars.REPLICAS || '2' }}
  MIN_REPLICAS: ${{ vars.MIN_REPLICAS || '2' }}
  MAX_REPLICAS: ${{ vars.MAX_REPLICAS || '10' }}
  CPU_TARGET_UTILIZATION: ${{ vars.CPU_TARGET_UTILIZATION || '70' }}
  MEMORY_TARGET_UTILIZATION: ${{ vars.MEMORY_TARGET_UTILIZATION || '80' }}
  
  # Docker Configuration
  DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
  DOCKERHUB_PASSWORD: ${{ secrets.DOCKERHUB_PASSWORD }}
  DOCKER_IMAGE_TAG: ${{ vars.DOCKER_IMAGE_TAG || 'latest' }}
  IMAGE_TAG: ${{ vars.IMAGE_TAG || 'latest' }}
  
  # Kubernetes Configuration
  KUBE_CONTEXT: ${{ vars.KUBE_CONTEXT || 'minikube' }}
  
  # Ingress Configuration
  INGRESS_ENABLED: ${{ vars.INGRESS_ENABLED || 'true' }}
  INGRESS_HOST: ${{ vars.INGRESS_HOST || 'devops-app.local' }}
  INGRESS_CLASS: ${{ vars.INGRESS_CLASS || 'nginx' }}
  TLS_ENABLED: ${{ vars.TLS_ENABLED || 'false' }}
  TLS_SECRET_NAME: ${{ vars.TLS_SECRET_NAME || 'devops-app-tls' }}
  
  # Database Configuration
  DB_HOST: ${{ secrets.DB_HOST || 'localhost' }}
  DB_PORT: ${{ secrets.DB_PORT || '5432' }}
  DB_NAME: ${{ secrets.DB_NAME || 'devopsdb' }}
  DB_USERNAME: ${{ secrets.DB_USERNAME }}
  DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
  
  # Application Secrets
  JWT_SECRET: ${{ secrets.JWT_SECRET }}
  API_KEY: ${{ secrets.API_KEY }}
  SESSION_SECRET: ${{ secrets.SESSION_SECRET }}
  
  # Monitoring - Prometheus
  PROMETHEUS_ENABLED: ${{ vars.PROMETHEUS_ENABLED || 'true' }}
  PROMETHEUS_NAMESPACE: ${{ vars.PROMETHEUS_NAMESPACE || 'monitoring' }}
  PROMETHEUS_RETENTION: ${{ vars.PROMETHEUS_RETENTION || '15d' }}
  PROMETHEUS_STORAGE_SIZE: ${{ vars.PROMETHEUS_STORAGE_SIZE || '10Gi' }}
  PROMETHEUS_SCRAPE_INTERVAL: ${{ vars.PROMETHEUS_SCRAPE_INTERVAL || '15s' }}
  PROMETHEUS_SCRAPE_TIMEOUT: ${{ vars.PROMETHEUS_SCRAPE_TIMEOUT || '10s' }}
  
  # Monitoring - Grafana
  GRAFANA_ENABLED: ${{ vars.GRAFANA_ENABLED || 'true' }}
  GRAFANA_ADMIN_USER: ${{ secrets.GRAFANA_ADMIN_USER || 'admin' }}
  GRAFANA_ADMIN_PASSWORD: ${{ secrets.GRAFANA_ADMIN_PASSWORD }}
  GRAFANA_PORT: ${{ vars.GRAFANA_PORT || '3000' }}
  GRAFANA_STORAGE_SIZE: ${{ vars.GRAFANA_STORAGE_SIZE || '5Gi' }}
  
  # Alerting Configuration
  ALERT_EMAIL_ENABLED: ${{ vars.ALERT_EMAIL_ENABLED || 'false' }}
  ALERT_EMAIL_TO: ${{ secrets.ALERT_EMAIL_TO }}
  ALERT_EMAIL_FROM: ${{ secrets.ALERT_EMAIL_FROM }}
  SMTP_HOST: ${{ secrets.SMTP_HOST }}
  SMTP_PORT: ${{ secrets.SMTP_PORT || '587' }}
  SMTP_USERNAME: ${{ secrets.SMTP_USERNAME }}
  SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
  SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
  
  # Resource Limits - Application
  APP_CPU_REQUEST: ${{ vars.APP_CPU_REQUEST || '100m' }}
  APP_CPU_LIMIT: ${{ vars.APP_CPU_LIMIT || '500m' }}
  APP_MEMORY_REQUEST: ${{ vars.APP_MEMORY_REQUEST || '128Mi' }}
  APP_MEMORY_LIMIT: ${{ vars.APP_MEMORY_LIMIT || '512Mi' }}
  
  # Resource Limits - Prometheus
  PROMETHEUS_CPU_REQUEST: ${{ vars.PROMETHEUS_CPU_REQUEST || '500m' }}
  PROMETHEUS_CPU_LIMIT: ${{ vars.PROMETHEUS_CPU_LIMIT || '2000m' }}
  PROMETHEUS_MEMORY_REQUEST: ${{ vars.PROMETHEUS_MEMORY_REQUEST || '1Gi' }}
  PROMETHEUS_MEMORY_LIMIT: ${{ vars.PROMETHEUS_MEMORY_LIMIT || '4Gi' }}
  
  # Resource Limits - Grafana
  GRAFANA_CPU_REQUEST: ${{ vars.GRAFANA_CPU_REQUEST || '100m' }}
  GRAFANA_CPU_LIMIT: ${{ vars.GRAFANA_CPU_LIMIT || '500m' }}
  GRAFANA_MEMORY_REQUEST: ${{ vars.GRAFANA_MEMORY_REQUEST || '256Mi' }}
  GRAFANA_MEMORY_LIMIT: ${{ vars.GRAFANA_MEMORY_LIMIT || '1Gi' }}
  
  # AWS Configuration
  AWS_REGION: ${{ vars.AWS_REGION || 'us-east-1' }}
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  EKS_CLUSTER_NAME: ${{ vars.EKS_CLUSTER_NAME || 'devops-cluster' }}
  
  # Git Configuration
  GIT_AUTHOR_NAME: ${{ vars.GIT_AUTHOR_NAME || github.actor }}
  GIT_AUTHOR_EMAIL: ${{ vars.GIT_AUTHOR_EMAIL || format('{0}@users.noreply.github.com', github.actor) }}
  GITHUB_USERNAME: ${{ github.actor }}
  GITHUB_EMAIL: ${{ vars.GITHUB_EMAIL || format('{0}@users.noreply.github.com', github.actor) }}
  
  # Deployment Configuration
  DEPLOY_TARGET: ${{ github.event.inputs.deploy_target || vars.DEPLOY_TARGET || 'prod' }}
  BUILD_PUSH: ${{ vars.BUILD_PUSH || 'true' }}
  CI: 'true'
  DRY_RUN: ${{ vars.DRY_RUN || 'false' }}
  
  # Minikube Configuration
  MINIKUBE_INGRESS: ${{ vars.MINIKUBE_INGRESS || 'true' }}
  MINIKUBE_MEMORY: ${{ vars.MINIKUBE_MEMORY || '4096' }}
  MINIKUBE_CPUS: ${{ vars.MINIKUBE_CPUS || '2' }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: ğŸ¯ Deployment Banner
        run: |
          echo "============================================================================"
          echo "DevOps Project Deployment Runner (GitHub Actions)"
          echo "============================================================================"
          echo "Deployment Target: ${{ env.DEPLOY_TARGET }}"
          echo "Triggered by: ${{ github.event_name }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Commit: ${{ github.sha }}"
          echo "============================================================================"
          echo ""

      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ğŸ” Validate Configuration
        run: |
          echo "ğŸ” Validating configuration..."
          echo ""
          
          # Check required secrets
          REQUIRED_SECRETS=(
            "DOCKERHUB_USERNAME"
            "DOCKERHUB_PASSWORD"
          )
          
          MISSING_SECRETS=()
          
          if [ -z "${{ secrets.DOCKERHUB_USERNAME }}" ]; then
            MISSING_SECRETS+=("DOCKERHUB_USERNAME")
          fi
          
          if [ -z "${{ secrets.DOCKERHUB_PASSWORD }}" ]; then
            MISSING_SECRETS+=("DOCKERHUB_PASSWORD")
          fi
          
          if [ "${{ env.DEPLOY_TARGET }}" == "prod" ]; then
            if [ -z "${{ secrets.AWS_ACCOUNT_ID }}" ]; then
              MISSING_SECRETS+=("AWS_ACCOUNT_ID")
            fi
          fi
          
          if [ ${#MISSING_SECRETS[@]} -gt 0 ]; then
            echo "âŒ Missing required secrets:"
            for secret in "${MISSING_SECRETS[@]}"; do
              echo "   - $secret"
            done
            echo ""
            echo "Please add these secrets in GitHub Settings â†’ Secrets and variables â†’ Actions"
            exit 1
          else
            echo "âœ… All required secrets are configured"
          fi
          
          # Validate deployment target
          if [[ "${{ env.DEPLOY_TARGET }}" != "local" && "${{ env.DEPLOY_TARGET }}" != "prod" ]]; then
            echo "âŒ Invalid DEPLOY_TARGET: ${{ env.DEPLOY_TARGET }}"
            echo "Valid options: 'local' or 'prod'"
            exit 1
          fi
          
          echo "âœ… Deployment target validated: ${{ env.DEPLOY_TARGET }}"
          echo ""

      - name: ğŸ”§ Setup Prerequisites
        run: |
          echo "ğŸ”§ Setting up prerequisites..."
          echo ""
          
          # Update package lists
          sudo apt-get update -qq
          
          # Install kubectl
          echo "ğŸ“¦ Installing kubectl..."
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
          
          # Install kustomize
          echo "ğŸ“¦ Installing kustomize..."
          curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh" | bash
          sudo mv kustomize /usr/local/bin/
          
          echo ""
          echo "Tool versions:"
          docker --version
          kubectl version --client
          kustomize version
          echo ""

      - name: ğŸ³ Docker Login
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: ğŸ”¨ Build Docker Image
        run: |
          echo "ğŸ”¨ Building Docker image..."
          echo ""
          
          IMAGE_NAME="${{ env.DOCKERHUB_USERNAME }}/${{ env.APP_NAME }}:${{ env.DOCKER_IMAGE_TAG }}"
          
          docker build \
            -t "$IMAGE_NAME" \
            -t "${{ env.DOCKERHUB_USERNAME }}/${{ env.APP_NAME }}:${{ github.sha }}" \
            ./app
          
          echo "âœ… Docker image built successfully"
          echo "   Image: $IMAGE_NAME"
          echo ""

      - name: ğŸš€ Push Docker Image
        if: env.BUILD_PUSH == 'true'
        run: |
          echo "ğŸš€ Pushing Docker image to DockerHub..."
          echo ""
          
          IMAGE_NAME="${{ env.DOCKERHUB_USERNAME }}/${{ env.APP_NAME }}:${{ env.DOCKER_IMAGE_TAG }}"
          
          docker push "$IMAGE_NAME"
          docker push "${{ env.DOCKERHUB_USERNAME }}/${{ env.APP_NAME }}:${{ github.sha }}"
          
          echo "âœ… Docker image pushed successfully"
          echo "   Repository: ${{ env.DOCKERHUB_USERNAME }}/${{ env.APP_NAME }}"
          echo "   Tags: ${{ env.DOCKER_IMAGE_TAG }}, ${{ github.sha }}"
          echo ""

      # ========== LOCAL DEPLOYMENT (MINIKUBE) ==========
      - name: ğŸš€ Deploy to Minikube (Local)
        if: env.DEPLOY_TARGET == 'local'
        run: |
          echo "ğŸš€ Deploying to Minikube (Local Environment)"
          echo ""
          
          # Install Minikube
          echo "ğŸ“¦ Installing Minikube..."
          curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
          sudo install minikube-linux-amd64 /usr/local/bin/minikube
          
          # Start Minikube
          echo "â–¶ï¸  Starting Minikube..."
          minikube start \
            --driver=docker \
            --memory=${{ env.MINIKUBE_MEMORY }} \
            --cpus=${{ env.MINIKUBE_CPUS }}
          
          # Enable ingress if configured
          if [[ "${{ env.MINIKUBE_INGRESS }}" == "true" ]]; then
            echo "ğŸŒ Enabling Ingress addon..."
            minikube addons enable ingress
          fi
          
          # Use Minikube's Docker daemon
          eval $(minikube docker-env)
          
          # Rebuild image in Minikube's Docker
          echo "ğŸ”¨ Building image in Minikube Docker..."
          docker build -t "${{ env.APP_NAME }}:latest" ./app
          
          echo "âœ… Minikube setup complete"
          echo ""

      - name: ğŸ“¦ Deploy Kubernetes Resources (Local)
        if: env.DEPLOY_TARGET == 'local'
        run: |
          echo "============================================================================"
          echo "ğŸ“¦ Deploying Kubernetes Resources (Local Environment)"
          echo "============================================================================"
          echo ""
          
          # Make deployment script executable
          chmod +x ./kubernetes/deploy_kubernetes.sh
          
          # Source and execute the deployment script
          export PROJECT_ROOT="${GITHUB_WORKSPACE}"
          
          # Run the deployment
          echo "ğŸš€ Executing deployment script..."
          ./kubernetes/deploy_kubernetes.sh local
          
          echo ""
          echo "âœ… Kubernetes deployment completed"
          echo ""

      - name: ğŸ“Š Deploy Monitoring Stack (Local)
        if: env.DEPLOY_TARGET == 'local' && env.PROMETHEUS_ENABLED == 'true'
        run: |
          echo "============================================================================"
          echo "ğŸ“Š Deploying Monitoring Stack (Local Environment)"
          echo "============================================================================"
          echo ""
          
          # Make monitoring script executable
          chmod +x ./monitoring/deploy_monitoring.sh
          
          # Source and execute the monitoring script
          export PROJECT_ROOT="${GITHUB_WORKSPACE}"
          
          # Run the monitoring deployment
          echo "ğŸš€ Executing monitoring deployment..."
          ./monitoring/deploy_monitoring.sh
          
          echo ""
          echo "âœ… Monitoring stack deployment completed"
          echo ""

      - name: âœ… Local Deployment Summary
        if: env.DEPLOY_TARGET == 'local'
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "  âœ… Application deployed to Minikube"
          echo ""
          
          MINIKUBE_IP=$(minikube ip)
          NODE_PORT=$(kubectl get svc "${{ env.APP_NAME }}-service" -n "${{ env.NAMESPACE }}" -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "N/A")
          
          echo "  ğŸŒ Minikube IP:   $MINIKUBE_IP"
          echo "  ğŸ”Œ Service Port:  $NODE_PORT"
          echo "  ğŸ“± App URL:       http://$MINIKUBE_IP:$NODE_PORT"
          echo ""
          echo "  ğŸ“Š Resources:"
          kubectl get all -n "${{ env.NAMESPACE }}"
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

      # ========== PRODUCTION DEPLOYMENT (AWS EKS) ==========
      - name: âš™ï¸ Configure AWS Credentials
        if: env.DEPLOY_TARGET == 'prod'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: ğŸ”§ Setup Terraform
        if: env.DEPLOY_TARGET == 'prod'
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0

      - name: ğŸ—ï¸ Deploy Infrastructure with Terraform
        if: env.DEPLOY_TARGET == 'prod'
        working-directory: ./infra/terraform
        run: |
          echo "â˜ï¸  Deploying to AWS EKS (Production Environment)"
          echo ""
          echo "ğŸ—ï¸  Deploying infrastructure with Terraform..."
          echo ""
          
          terraform init -upgrade
          
          echo ""
          echo "ğŸ“‹ Terraform Plan:"
          terraform plan
          
          echo ""
          echo "ğŸš€ Applying Terraform configuration..."
          terraform apply -auto-approve
          
          echo ""
          echo "âœ… Infrastructure deployment completed"
          echo ""

      - name: âš™ï¸ Configure kubectl for EKS
        if: env.DEPLOY_TARGET == 'prod'
        working-directory: ./infra/terraform
        run: |
          echo "âš™ï¸  Configuring kubectl context for EKS..."
          echo ""
          
          REGION=$(terraform output -raw region)
          CLUSTER_NAME=$(terraform output -raw cluster_name)
          
          aws eks update-kubeconfig \
            --region "$REGION" \
            --name "$CLUSTER_NAME"
          
          echo "âœ… kubectl configured for EKS cluster: $CLUSTER_NAME"
          echo ""
          
          # Verify connection
          echo "ğŸ” Verifying cluster connection..."
          kubectl cluster-info
          kubectl get nodes
          echo ""

      - name: ğŸ“¦ Deploy Kubernetes Resources (Production)
        if: env.DEPLOY_TARGET == 'prod'
        run: |
          echo "============================================================================"
          echo "ğŸ“¦ Deploying Kubernetes Resources (Production Environment)"
          echo "============================================================================"
          echo ""
          
          # Make deployment script executable
          chmod +x ./kubernetes/deploy_kubernetes.sh
          
          # Source and execute the deployment script
          export PROJECT_ROOT="${GITHUB_WORKSPACE}"
          
          # Run the deployment
          echo "ğŸš€ Executing deployment script..."
          ./kubernetes/deploy_kubernetes.sh prod
          
          echo ""
          echo "âœ… Kubernetes deployment completed"
          echo ""

      - name: ğŸ“Š Deploy Monitoring Stack (Production)
        if: env.DEPLOY_TARGET == 'prod' && env.PROMETHEUS_ENABLED == 'true'
        run: |
          echo "============================================================================"
          echo "ğŸ“Š Deploying Monitoring Stack (Production Environment)"
          echo "============================================================================"
          echo ""
          
          # Make monitoring script executable
          chmod +x ./monitoring/deploy_monitoring.sh
          
          # Source and execute the monitoring script
          export PROJECT_ROOT="${GITHUB_WORKSPACE}"
          
          # Run the monitoring deployment
          echo "ğŸš€ Executing monitoring deployment..."
          ./monitoring/deploy_monitoring.sh
          
          echo ""
          echo "âœ… Monitoring stack deployment completed"
          echo ""

      - name: âœ… Production Deployment Summary
        if: env.DEPLOY_TARGET == 'prod'
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "  âœ… Application deployed to AWS EKS"
          echo ""
          echo "  ğŸ“Š Deployment Resources:"
          kubectl get all -n "${{ env.NAMESPACE }}"
          echo ""
          
          if [[ "${{ env.PROMETHEUS_ENABLED }}" == "true" ]]; then
            echo "  ğŸ“ˆ Monitoring Resources:"
            kubectl get all -n "${{ env.PROMETHEUS_NAMESPACE }}"
            echo ""
          fi
          
          echo "  ğŸŒ Services:"
          kubectl get svc -n "${{ env.NAMESPACE }}"
          echo ""
          
          echo "  ğŸ”— Ingress:"
          kubectl get ingress -n "${{ env.NAMESPACE }}"
          echo ""
          
          echo "  â„¹ï¸  Note: Use LoadBalancer or Ingress to expose services externally"
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

      - name: ğŸ” Final Health Check
        if: always()
        run: |
          echo "ğŸ” Final Health Check"
          echo ""
          
          echo "ğŸ“‹ Pod Status:"
          kubectl get pods -n "${{ env.NAMESPACE }}" -o wide || true
          echo ""
          
          echo "ğŸ“‹ Service Status:"
          kubectl get svc -n "${{ env.NAMESPACE }}" || true
          echo ""
          
          if [[ "${{ env.PROMETHEUS_ENABLED }}" == "true" ]]; then
            echo "ğŸ“‹ Monitoring Pod Status:"
            kubectl get pods -n "${{ env.PROMETHEUS_NAMESPACE }}" || true
            echo ""
          fi
          
          echo "ğŸ‰ Deployment workflow completed!"