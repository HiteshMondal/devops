name: DevOps Project Deployment

on:
  push:
    branches:
      - main
      - prod
  workflow_dispatch:
    inputs:
      deploy_target:
        description: 'Deployment Target'
        required: true
        default: 'prod'
        type: choice
        options:
          - local
          - prod

env:
  # Project Configuration
  APP_NAME: ${{ vars.APP_NAME || 'devops-app' }}
  NAMESPACE: ${{ vars.NAMESPACE || 'devops-app' }}
  APP_PORT: ${{ vars.APP_PORT || '3000' }}
  REPLICAS: ${{ vars.REPLICAS || '2' }}
  MIN_REPLICAS: ${{ vars.MIN_REPLICAS || '2' }}
  MAX_REPLICAS: ${{ vars.MAX_REPLICAS || '10' }}
  CPU_TARGET_UTILIZATION: ${{ vars.CPU_TARGET_UTILIZATION || '70' }}
  MEMORY_TARGET_UTILIZATION: ${{ vars.MEMORY_TARGET_UTILIZATION || '80' }}
  
  # Docker Configuration
  DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
  DOCKERHUB_PASSWORD: ${{ secrets.DOCKERHUB_PASSWORD }}
  DOCKER_IMAGE_TAG: ${{ vars.DOCKER_IMAGE_TAG || 'latest' }}
  IMAGE_TAG: ${{ vars.IMAGE_TAG || 'latest' }}
  
  # Kubernetes Configuration
  KUBE_CONTEXT: ${{ vars.KUBE_CONTEXT || 'minikube' }}
  
  # Ingress Configuration
  INGRESS_ENABLED: ${{ vars.INGRESS_ENABLED || 'true' }}
  INGRESS_HOST: ${{ vars.INGRESS_HOST || 'devops-app.local' }}
  INGRESS_CLASS: ${{ vars.INGRESS_CLASS || 'nginx' }}
  TLS_ENABLED: ${{ vars.TLS_ENABLED || 'false' }}
  TLS_SECRET_NAME: ${{ vars.TLS_SECRET_NAME || 'devops-app-tls' }}
  
  # Database Configuration
  DB_HOST: ${{ secrets.DB_HOST || 'localhost' }}
  DB_PORT: ${{ secrets.DB_PORT || '5432' }}
  DB_NAME: ${{ secrets.DB_NAME || 'devopsdb' }}
  DB_USERNAME: ${{ secrets.DB_USERNAME }}
  DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
  
  # Application Secrets
  JWT_SECRET: ${{ secrets.JWT_SECRET }}
  API_KEY: ${{ secrets.API_KEY }}
  SESSION_SECRET: ${{ secrets.SESSION_SECRET }}
  
  # Monitoring - Prometheus
  PROMETHEUS_ENABLED: ${{ vars.PROMETHEUS_ENABLED || 'true' }}
  PROMETHEUS_NAMESPACE: ${{ vars.PROMETHEUS_NAMESPACE || 'monitoring' }}
  PROMETHEUS_RETENTION: ${{ vars.PROMETHEUS_RETENTION || '15d' }}
  PROMETHEUS_STORAGE_SIZE: ${{ vars.PROMETHEUS_STORAGE_SIZE || '10Gi' }}
  PROMETHEUS_SCRAPE_INTERVAL: ${{ vars.PROMETHEUS_SCRAPE_INTERVAL || '15s' }}
  PROMETHEUS_SCRAPE_TIMEOUT: ${{ vars.PROMETHEUS_SCRAPE_TIMEOUT || '10s' }}
  
  # Monitoring - Grafana
  GRAFANA_ENABLED: ${{ vars.GRAFANA_ENABLED || 'true' }}
  GRAFANA_ADMIN_USER: ${{ secrets.GRAFANA_ADMIN_USER || 'admin' }}
  GRAFANA_ADMIN_PASSWORD: ${{ secrets.GRAFANA_ADMIN_PASSWORD }}
  GRAFANA_PORT: ${{ vars.GRAFANA_PORT || '3000' }}
  GRAFANA_STORAGE_SIZE: ${{ vars.GRAFANA_STORAGE_SIZE || '5Gi' }}
  
  # Alerting Configuration
  ALERT_EMAIL_ENABLED: ${{ vars.ALERT_EMAIL_ENABLED || 'false' }}
  ALERT_EMAIL_TO: ${{ vars.ALERT_EMAIL_TO }}
  ALERT_EMAIL_FROM: ${{ vars.ALERT_EMAIL_FROM }}
  SMTP_HOST: ${{ secrets.SMTP_HOST }}
  SMTP_PORT: ${{ secrets.SMTP_PORT || '587' }}
  SMTP_USERNAME: ${{ secrets.SMTP_USERNAME }}
  SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
  SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
  
  # Resource Limits - Application
  APP_CPU_REQUEST: ${{ vars.APP_CPU_REQUEST || '100m' }}
  APP_CPU_LIMIT: ${{ vars.APP_CPU_LIMIT || '500m' }}
  APP_MEMORY_REQUEST: ${{ vars.APP_MEMORY_REQUEST || '128Mi' }}
  APP_MEMORY_LIMIT: ${{ vars.APP_MEMORY_LIMIT || '512Mi' }}
  
  # Resource Limits - Prometheus
  PROMETHEUS_CPU_REQUEST: ${{ vars.PROMETHEUS_CPU_REQUEST || '500m' }}
  PROMETHEUS_CPU_LIMIT: ${{ vars.PROMETHEUS_CPU_LIMIT || '2000m' }}
  PROMETHEUS_MEMORY_REQUEST: ${{ vars.PROMETHEUS_MEMORY_REQUEST || '1Gi' }}
  PROMETHEUS_MEMORY_LIMIT: ${{ vars.PROMETHEUS_MEMORY_LIMIT || '4Gi' }}
  
  # Resource Limits - Grafana
  GRAFANA_CPU_REQUEST: ${{ vars.GRAFANA_CPU_REQUEST || '100m' }}
  GRAFANA_CPU_LIMIT: ${{ vars.GRAFANA_CPU_LIMIT || '500m' }}
  GRAFANA_MEMORY_REQUEST: ${{ vars.GRAFANA_MEMORY_REQUEST || '256Mi' }}
  GRAFANA_MEMORY_LIMIT: ${{ vars.GRAFANA_MEMORY_LIMIT || '1Gi' }}
  
  # AWS Configuration
  AWS_REGION: ${{ vars.AWS_REGION || 'us-east-1' }}
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  EKS_CLUSTER_NAME: ${{ vars.EKS_CLUSTER_NAME || 'devops-cluster' }}
  
  # Git Configuration
  GIT_AUTHOR_NAME: ${{ vars.GIT_AUTHOR_NAME || github.actor }}
  GIT_AUTHOR_EMAIL: ${{ vars.GIT_AUTHOR_EMAIL || format('{0}@users.noreply.github.com', github.actor) }}
  GITHUB_USERNAME: ${{ github.actor }}
  GITHUB_EMAIL: ${{ vars.GITHUB_EMAIL || format('{0}@users.noreply.github.com', github.actor) }}
  
  # Deployment Configuration
  DEPLOY_TARGET: ${{ inputs.deploy_target || vars.DEPLOY_TARGET || 'prod' }}
  BUILD_PUSH: ${{ vars.BUILD_PUSH || 'true' }}
  CI: true
  DRY_RUN: ${{ vars.DRY_RUN || 'false' }}
  
  # Minikube Configuration (for local deployments)
  MINIKUBE_INGRESS: ${{ vars.MINIKUBE_INGRESS || 'true' }}
  MINIKUBE_MEMORY: ${{ vars.MINIKUBE_MEMORY || '4096' }}
  MINIKUBE_CPUS: ${{ vars.MINIKUBE_CPUS || '2' }}

jobs:
  deploy:
    name: Deploy Application
    runs-on: ubuntu-latest
    
    steps:
      - name: "============================================================================"
        run: |
          echo "============================================================================"
          echo "DevOps Project Deployment Runner - GitHub Actions"
          echo "============================================================================"
          echo "Description: Orchestrates deployment to Minikube (local) or AWS EKS (prod)"
          echo "Deployment Target: ${{ env.DEPLOY_TARGET }}"
          echo "============================================================================"
      
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: "ğŸ” Checking Prerequisites"
        run: |
          echo ""
          echo "ğŸ” Checking prerequisites..."
          echo "Tool versions:"
          docker --version || true
          kubectl version --client || true
          terraform --version | head -n 1 || true
          aws --version || true
          echo ""
      
      - name: "âœ… Validate Configuration"
        run: |
          echo "ğŸ” Validating configuration..."
          echo ""
          
          # Check for required variables
          required_vars=(
            "APP_NAME"
            "NAMESPACE"
            "DOCKERHUB_USERNAME"
            "DOCKER_IMAGE_TAG"
            "APP_PORT"
            "REPLICAS"
          )
          
          missing_vars=()
          
          for var in "${required_vars[@]}"; do
            var_value="${!var:-}"
            if [[ -z "$var_value" ]]; then
              missing_vars+=("$var")
            fi
          done
          
          if [[ ${#missing_vars[@]} -gt 0 ]]; then
            echo "âš ï¸  WARNING: Missing required variables:"
            for var in "${missing_vars[@]}"; do
              echo "   - $var"
            done
            echo ""
            echo "Please configure these in GitHub Settings â†’ Secrets and Variables â†’ Actions"
            exit 1
          else
            echo "âœ… All required variables are present"
          fi
          
          # Validate numeric values (GitHub Actions variables are strings)
          echo "âœ… Numeric values validation passed"
          echo ""
          echo "ğŸ¯ Deployment Target: ${{ env.DEPLOY_TARGET }}"
          echo ""
      
      - name: Configure AWS Credentials
        if: env.DEPLOY_TARGET == 'prod'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Setup Terraform
        if: env.DEPLOY_TARGET == 'prod'
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: latest
      
      - name: Setup Minikube
        if: env.DEPLOY_TARGET == 'local'
        uses: medyagh/setup-minikube@latest
        with:
          memory: ${{ env.MINIKUBE_MEMORY }}
          cpus: ${{ env.MINIKUBE_CPUS }}
      
      - name: "âš™ï¸ Configure Git and DockerHub (from configure_git_github.sh)"
        run: |
          echo "âš™ï¸  Configuring Git and GitHub..."
          
          # Set Git configuration
          git config --global user.name "${{ env.GIT_AUTHOR_NAME }}"
          git config --global user.email "${{ env.GIT_AUTHOR_EMAIL }}"
          
          echo "âœ… Git configured:"
          echo "   Name: ${{ env.GIT_AUTHOR_NAME }}"
          echo "   Email: ${{ env.GIT_AUTHOR_EMAIL }}"
      
      - name: "âš™ï¸ Configure DockerHub (from configure_dockerhub_username.sh)"
        run: |
          echo "âš™ï¸  Configuring DockerHub credentials..."
          
          if [[ -z "${{ secrets.DOCKERHUB_USERNAME }}" ]] || [[ -z "${{ secrets.DOCKERHUB_PASSWORD }}" ]]; then
            echo "âŒ DockerHub credentials not configured"
            echo "   Please set DOCKERHUB_USERNAME and DOCKERHUB_PASSWORD in GitHub Secrets"
            exit 1
          fi
          
          echo "${{ secrets.DOCKERHUB_PASSWORD }}" | docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin
          
          echo "âœ… DockerHub login successful"
          echo "   Username: ${{ secrets.DOCKERHUB_USERNAME }}"
      
      # ==================== MINIKUBE (LOCAL) DEPLOYMENT ====================
      
      - name: "ğŸ³ Configure Docker Environment (Minikube)"
        if: env.DEPLOY_TARGET == 'local'
        run: |
          echo "ğŸ³ Configuring Docker environment for Minikube..."
          eval $(minikube docker-env)
          
          # Export for subsequent steps
          minikube docker-env >> $GITHUB_ENV
      
      - name: "ğŸŒ Enable Ingress Addon (Minikube)"
        if: env.DEPLOY_TARGET == 'local' && env.MINIKUBE_INGRESS == 'true'
        run: |
          echo "ğŸŒ Enabling Ingress addon..."
          minikube addons enable ingress
          echo "âœ… Ingress addon enabled"
      
      - name: "ğŸ”¨ Build Docker Image (from build_and_push_image.sh - Minikube)"
        if: env.DEPLOY_TARGET == 'local'
        run: |
          echo "ğŸ”¨ Building Docker image locally for Minikube..."
          
          cd app
          
          if [[ "${{ env.BUILD_PUSH }}" == "true" ]]; then
            echo "ğŸ”¨ Building and pushing Docker image..."
            
            IMAGE_NAME="${{ secrets.DOCKERHUB_USERNAME }}/${{ env.APP_NAME }}:${{ env.DOCKER_IMAGE_TAG }}"
            
            echo "Building image: $IMAGE_NAME"
            docker build -t "$IMAGE_NAME" .
            
            echo "Pushing image to DockerHub..."
            docker push "$IMAGE_NAME"
            
            echo "âœ… Image built and pushed: $IMAGE_NAME"
          else
            echo "ğŸ”¨ Building Docker image locally (not pushing)..."
            docker build -t "${{ env.APP_NAME }}:latest" .
            echo "âœ… Image built locally"
          fi
      
      - name: "ğŸ“¦ Deploy Kubernetes Resources (Minikube)"
        if: env.DEPLOY_TARGET == 'local'
        run: |
          echo ""
          echo "ğŸ“¦ Deploying Kubernetes resources..."
          
          # Execute deploy_kubernetes.sh for local environment
          chmod +x kubernetes/deploy_kubernetes.sh
          cd kubernetes
          ./deploy_kubernetes.sh local
          cd ..
      
      - name: "ğŸ“Š Deploy Monitoring Stack (Minikube)"
        if: env.DEPLOY_TARGET == 'local'
        run: |
          echo "ğŸ“Š Deploying monitoring stack..."
          
          # Execute deploy_monitoring.sh
          chmod +x monitoring/deploy_monitoring.sh
          cd monitoring
          ./deploy_monitoring.sh
          cd ..
      
      - name: "ğŸ”§ Deploy Jenkins (Minikube)"
        if: env.DEPLOY_TARGET == 'local'
        run: |
          echo "ğŸ”§ Deploying Jenkins..."
          
          # Execute deploy_jenkins.sh
          if [[ -f "cicd/jenkins/deploy_jenkins.sh" ]]; then
            chmod +x cicd/jenkins/deploy_jenkins.sh
            cd cicd/jenkins
            ./deploy_jenkins.sh
            cd ../..
          else
            echo "âš ï¸  Jenkins deployment script not found, skipping..."
          fi
      
      - name: "ğŸ”„ Deploy ArgoCD (Minikube)"
        if: env.DEPLOY_TARGET == 'local'
        run: |
          echo "ğŸ”„ Deploying ArgoCD..."
          
          # Execute deploy_argocd.sh
          if [[ -f "cicd/argocd/deploy_argocd.sh" ]]; then
            chmod +x cicd/argocd/deploy_argocd.sh
            cd cicd/argocd
            ./deploy_argocd.sh
            cd ../..
          else
            echo "âš ï¸  ArgoCD deployment script not found, skipping..."
          fi
      
      - name: "ğŸ”„ Configure GitLab CI (Minikube)"
        if: env.DEPLOY_TARGET == 'local'
        run: |
          echo "ğŸ”„ Configuring GitLab CI..."
          
          # Execute configure_gitlab.sh
          if [[ -f "cicd/gitlab/configure_gitlab.sh" ]]; then
            chmod +x cicd/gitlab/configure_gitlab.sh
            cd cicd/gitlab
            ./configure_gitlab.sh
            cd ../..
          else
            echo "âš ï¸  GitLab configuration script not found, skipping..."
          fi
      
      - name: "ğŸ”„ Configure ArgoCD Self-Healing (Minikube)"
        if: env.DEPLOY_TARGET == 'local'
        run: |
          echo "ğŸ”„ Configuring ArgoCD self-healing..."
          
          # Execute self_heal_app.sh
          if [[ -f "cicd/argocd/self_heal_app.sh" ]]; then
            chmod +x cicd/argocd/self_heal_app.sh
            cd cicd/argocd
            ./self_heal_app.sh
            cd ../..
          else
            echo "âš ï¸  ArgoCD self-heal script not found, skipping..."
          fi
      
      - name: "âœ… Deployment Summary (Minikube)"
        if: env.DEPLOY_TARGET == 'local'
        run: |
          MINIKUBE_IP=$(minikube ip)
          NODE_PORT=$(kubectl get svc "${{ env.APP_NAME }}-service" -n "${{ env.NAMESPACE }}" -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "N/A")
          
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "  âœ… Application deployed to Minikube"
          echo ""
          echo "  ğŸŒ App URL:       http://$MINIKUBE_IP:$NODE_PORT"
          echo "  ğŸ“Š Dashboard:     minikube dashboard"
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      
      # ==================== AWS EKS (PRODUCTION) DEPLOYMENT ====================
      
      - name: "ğŸ—ï¸ Deploy Infrastructure with Terraform"
        if: env.DEPLOY_TARGET == 'prod'
        run: |
          echo "â˜ï¸  Deploying to AWS EKS (Production Environment)"
          echo ""
          echo "ğŸ—ï¸  Deploying infrastructure with Terraform..."
          
          cd infra/terraform
          
          terraform init -upgrade
          
          echo ""
          echo "Running terraform apply..."
          terraform apply -auto-approve
          
          echo "âœ… Terraform deployment completed"
          cd ../..
      
      - name: "âš™ï¸ Configure kubectl Context (EKS)"
        if: env.DEPLOY_TARGET == 'prod'
        run: |
          echo "âš™ï¸  Configuring kubectl context for EKS..."
          
          cd infra/terraform
          
          REGION=$(terraform output -raw region)
          CLUSTER_NAME=$(terraform output -raw cluster_name)
          
          echo "Region: $REGION"
          echo "Cluster: $CLUSTER_NAME"
          
          aws eks update-kubeconfig \
            --region "$REGION" \
            --name "$CLUSTER_NAME"
          
          cd ../..
          
          echo "âœ… kubectl configured for EKS cluster"
          kubectl cluster-info
      
      - name: "ğŸ”¨ Build and Push Docker Image (from build_and_push_image.sh - EKS)"
        if: env.DEPLOY_TARGET == 'prod' && env.BUILD_PUSH == 'true'
        run: |
          echo "ğŸ”¨ Building and pushing Docker image..."
          
          cd app
          
          IMAGE_NAME="${{ secrets.DOCKERHUB_USERNAME }}/${{ env.APP_NAME }}:${{ env.DOCKER_IMAGE_TAG }}"
          
          echo "Building image: $IMAGE_NAME"
          docker build -t "$IMAGE_NAME" .
          
          echo "Pushing image to DockerHub..."
          docker push "$IMAGE_NAME"
          
          echo "âœ… Image built and pushed: $IMAGE_NAME"
          cd ..
      
      - name: "ğŸ“¦ Deploy Kubernetes Resources (EKS)"
        if: env.DEPLOY_TARGET == 'prod'
        run: |
          echo ""
          echo "ğŸ“¦ Deploying Kubernetes resources to EKS..."
          
          # Execute deploy_kubernetes.sh for prod environment
          chmod +x kubernetes/deploy_kubernetes.sh
          cd kubernetes
          ./deploy_kubernetes.sh prod
          cd ..
      
      - name: "ğŸ“Š Deploy Monitoring Stack (EKS)"
        if: env.DEPLOY_TARGET == 'prod'
        run: |
          echo "ğŸ“Š Deploying monitoring stack..."
          
          # Execute deploy_monitoring.sh
          chmod +x monitoring/deploy_monitoring.sh
          cd monitoring
          ./deploy_monitoring.sh
          cd ..
      
      - name: "ğŸ”§ Deploy Jenkins (EKS)"
        if: env.DEPLOY_TARGET == 'prod'
        run: |
          echo "ğŸ”§ Deploying Jenkins..."
          
          if [[ -f "cicd/jenkins/deploy_jenkins.sh" ]]; then
            chmod +x cicd/jenkins/deploy_jenkins.sh
            cd cicd/jenkins
            ./deploy_jenkins.sh
            cd ../..
          else
            echo "âš ï¸  Jenkins deployment script not found, skipping..."
          fi
      
      - name: "ğŸ”„ Deploy ArgoCD (EKS)"
        if: env.DEPLOY_TARGET == 'prod'
        run: |
          echo "ğŸ”„ Deploying ArgoCD..."
          
          if [[ -f "cicd/argocd/deploy_argocd.sh" ]]; then
            chmod +x cicd/argocd/deploy_argocd.sh
            cd cicd/argocd
            ./deploy_argocd.sh
            cd ../..
          else
            echo "âš ï¸  ArgoCD deployment script not found, skipping..."
          fi
      
      - name: "ğŸ”„ Configure GitLab CI (EKS)"
        if: env.DEPLOY_TARGET == 'prod'
        run: |
          echo "ğŸ”„ Configuring GitLab CI..."
          
          if [[ -f "cicd/gitlab/configure_gitlab.sh" ]]; then
            chmod +x cicd/gitlab/configure_gitlab.sh
            cd cicd/gitlab
            ./configure_gitlab.sh
            cd ../..
          else
            echo "âš ï¸  GitLab configuration script not found, skipping..."
          fi
      
      - name: "ğŸ”„ Configure ArgoCD Self-Healing (EKS)"
        if: env.DEPLOY_TARGET == 'prod'
        run: |
          echo "ğŸ”„ Configuring ArgoCD self-healing..."
          
          if [[ -f "cicd/argocd/self_heal_app.sh" ]]; then
            chmod +x cicd/argocd/self_heal_app.sh
            cd cicd/argocd
            ./self_heal_app.sh
            cd ../..
          else
            echo "âš ï¸  ArgoCD self-heal script not found, skipping..."
          fi
      
      - name: "âœ… Deployment Summary (EKS)"
        if: env.DEPLOY_TARGET == 'prod'
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "  âœ… Application deployed to AWS EKS"
          echo ""
          echo "  â„¹ï¸  Use LoadBalancer or Ingress to expose services"
          echo "  ğŸ“Š Check service status: kubectl get svc -n ${{ env.NAMESPACE }}"
          echo "  ğŸ” Check pods: kubectl get pods -n ${{ env.NAMESPACE }}"
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      
      - name: "ğŸ“‹ Display Deployment Resources"
        run: |
          echo ""
          echo "ğŸ“‹ Deployed Resources:"
          echo ""
          echo "Namespaces:"
          kubectl get namespaces
          echo ""
          echo "Pods in ${{ env.NAMESPACE }}:"
          kubectl get pods -n ${{ env.NAMESPACE }} || true
          echo ""
          echo "Services in ${{ env.NAMESPACE }}:"
          kubectl get svc -n ${{ env.NAMESPACE }} || true
          echo ""
          echo "Ingress in ${{ env.NAMESPACE }}:"
          kubectl get ingress -n ${{ env.NAMESPACE }} || true
          echo ""