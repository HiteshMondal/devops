name: Production CI/CD (Minikube)

on:
  push:
    branches:
      - main

env:
  PROJECT_ROOT: ${{ github.workspace }}
  APP_NAME: devops-app
  NAMESPACE: devops-app
  IMAGE_NAME: devops-app
  IMAGE_TAG: latest

jobs:
  build-and-deploy:
    runs-on: self-hosted   # Machine with Docker + Minikube installed

    steps:
      # ----------------------------
      # Checkout
      # ----------------------------
      - name: Checkout repository
        uses: actions/checkout@v3

      # ----------------------------
      # Load .env variables
      # ----------------------------
      - name: Load environment variables
        run: |
          ENV_FILE="$GITHUB_WORKSPACE/.env"
          if [[ -f "$ENV_FILE" ]]; then
            set -a
            source "$ENV_FILE"
            set +a
            env | grep -v '^_' >> $GITHUB_ENV
          else
            echo "‚ùå .env file not found"
            exit 1
          fi

      # ----------------------------
      # Node setup
      # ----------------------------
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: "18"

      - name: Install app dependencies
        run: npm install
        working-directory: ./app

      # ----------------------------
      # Minikube
      # ----------------------------
      - name: Ensure Minikube is running
        run: |
          if [[ "$(minikube status --format='{{.Host}}')" != "Running" ]]; then
            minikube start --driver=docker
            minikube addons enable ingress
          fi

      # ----------------------------
      # Docker build (inside Minikube)
      # ----------------------------
      - name: Build Docker image inside Minikube
        run: |
          eval $(minikube docker-env)
          docker build -t $IMAGE_NAME:$IMAGE_TAG ./app

      # ----------------------------
      # App Deployment
      # ----------------------------
      - name: Deploy application (Kustomize)
        run: |
          kubectl kustomize kubernetes/overlays/local | kubectl apply -f -

      # ----------------------------
      # Monitoring Deployment
      # ----------------------------
      - name: Deploy Monitoring Stack
        run: |
          echo "üìä Deploying Monitoring Stack..."

          BASE_MONITORING_PATH="$PROJECT_ROOT/kubernetes/base/monitoring"
          PROM_CONFIG="$PROJECT_ROOT/monitoring/prometheus/prometheus.yml"
          PROM_ALERTS="$PROJECT_ROOT/monitoring/prometheus/alerts.yml"

          # Namespace
          kubectl apply -f - <<EOF
apiVersion: v1
kind: Namespace
metadata:
  name: monitoring
EOF

          # Grafana secret
          : "${GRAFANA_ADMIN_PASSWORD:=admin123}"
          kubectl create secret generic grafana-secrets \
            --from-literal=admin-password="$GRAFANA_ADMIN_PASSWORD" \
            -n monitoring \
            --dry-run=client -o yaml | kubectl apply -f -

          # Dashboards
          kubectl apply -f "$BASE_MONITORING_PATH/dashboard-configmap.yaml"

          # Prometheus config
          kubectl create configmap prometheus-config \
            --from-file=prometheus.yml="$PROM_CONFIG" \
            --from-file=alerts.yml="$PROM_ALERTS" \
            -n monitoring \
            --dry-run=client -o yaml | kubectl apply -f -

          # Grafana datasource
          kubectl create configmap grafana-datasource \
            --from-literal=datasource.yaml="apiVersion: 1
datasources:
  - name: Prometheus
    type: prometheus
    access: proxy
    url: http://prometheus.monitoring.svc.cluster.local:9090
    isDefault: true" \
            -n monitoring \
            --dry-run=client -o yaml | kubectl apply -f -

          # Dummy dashboard configmaps (avoid crashloops)
          kubectl create configmap grafana-dashboard \
            --from-literal=dummy=empty \
            -n monitoring \
            --dry-run=client -o yaml | kubectl apply -f -

          kubectl create configmap grafana-dashboard-config \
            --from-literal=dummy=empty \
            -n monitoring \
            --dry-run=client -o yaml | kubectl apply -f -

          # Deploy workloads
          kubectl apply -f "$BASE_MONITORING_PATH/prometheus.yaml"
          kubectl apply -f "$BASE_MONITORING_PATH/grafana.yaml"

          # Restart to pick up configs
          kubectl rollout restart deployment/prometheus -n monitoring
          kubectl rollout restart deployment/grafana -n monitoring

      # ----------------------------
      # Expose Services
      # ----------------------------
      - name: Expose Monitoring Services (NodePort)
        run: |
          kubectl apply -f - <<EOF
apiVersion: v1
kind: Service
metadata:
  name: prometheus
  namespace: monitoring
spec:
  selector:
    app: prometheus
  ports:
    - port: 9090
      targetPort: 9090
  type: NodePort
---
apiVersion: v1
kind: Service
metadata:
  name: grafana
  namespace: monitoring
spec:
  selector:
    app: grafana
  ports:
    - port: 3000
      targetPort: 3000
  type: NodePort
EOF

      # ----------------------------
      # Wait for rollouts
      # ----------------------------
      - name: Wait for Monitoring Rollouts
        run: |
          kubectl rollout status deployment/prometheus -n monitoring --timeout=300s
          kubectl rollout status deployment/grafana -n monitoring --timeout=300s

      # ----------------------------
      # Output URLs (CI-safe)
      # ----------------------------
      - name: Output Service URLs
        run: |
          MINIKUBE_IP=$(minikube ip)

          APP_PORT=$(kubectl get svc "$APP_NAME-service" -n "$NAMESPACE" \
            -o jsonpath='{.spec.ports[0].nodePort}')

          PROM_PORT=$(kubectl get svc prometheus -n monitoring \
            -o jsonpath='{.spec.ports[0].nodePort}')

          GRAF_PORT=$(kubectl get svc grafana -n monitoring \
            -o jsonpath='{.spec.ports[0].nodePort}')

          echo ""
          echo "üöÄ Deployment successful"
          echo "üåê App URL:        http://$MINIKUBE_IP:$APP_PORT"
          echo "üìä Prometheus URL: http://$MINIKUBE_IP:$PROM_PORT"
          echo "üìä Grafana URL:    http://$MINIKUBE_IP:$GRAF_PORT"
          echo ""
