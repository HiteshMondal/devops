name: DevOps Project Deployment

on:
  workflow_dispatch:
    inputs:
      deploy_target:
        description: 'Deployment target'
        required: true
        type: choice
        options:
          - local
          - prod
        default: 'local'
      build_push:
        description: 'Build and push Docker image'
        required: false
        type: boolean
        default: true
      dry_run:
        description: 'Dry run mode (test without actual deployment)'
        required: false
        type: boolean
        default: false
  
  push:
    branches:
      - main
      - master
    paths-ignore:
      - '**.md'
      - 'docs/**'

env:
  # Project Configuration
  APP_NAME: ${{ vars.APP_NAME || 'devops-app' }}
  NAMESPACE: ${{ vars.NAMESPACE || 'devops-app' }}
  APP_PORT: ${{ vars.APP_PORT != '' && vars.APP_PORT || '3000' }}
  REPLICAS: ${{ vars.REPLICAS || '2' }}
  MIN_REPLICAS: ${{ vars.MIN_REPLICAS || '2' }}
  MAX_REPLICAS: ${{ vars.MAX_REPLICAS || '10' }}
  CPU_TARGET_UTILIZATION: ${{ vars.CPU_TARGET_UTILIZATION || '70' }}
  MEMORY_TARGET_UTILIZATION: ${{ vars.MEMORY_TARGET_UTILIZATION || '80' }}
  
  # Docker Configuration
  DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
  DOCKER_IMAGE_TAG: ${{ vars.DOCKER_IMAGE_TAG || 'latest' }}
  IMAGE_TAG: ${{ vars.IMAGE_TAG || 'latest' }}
  
  # Ingress Configuration
  INGRESS_ENABLED: ${{ vars.INGRESS_ENABLED || 'true' }}
  INGRESS_HOST: ${{ vars.INGRESS_HOST || 'devops-app.local' }}
  INGRESS_CLASS: ${{ vars.INGRESS_CLASS || 'nginx' }}
  TLS_ENABLED: ${{ vars.TLS_ENABLED || 'false' }}
  TLS_SECRET_NAME: ${{ vars.TLS_SECRET_NAME || 'devops-app-tls' }}
  
  # Database Configuration
  DB_HOST: ${{ vars.DB_HOST || 'localhost' }}
  DB_PORT: ${{ vars.DB_PORT || '5432' }}
  DB_NAME: ${{ vars.DB_NAME || 'devopsdb' }}
  DB_USERNAME: ${{ secrets.DB_USERNAME }}
  DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
  
  # Application Secrets
  JWT_SECRET: ${{ secrets.JWT_SECRET }}
  API_KEY: ${{ secrets.API_KEY }}
  SESSION_SECRET: ${{ secrets.SESSION_SECRET }}
  
  # Monitoring - Prometheus
  PROMETHEUS_ENABLED: ${{ vars.PROMETHEUS_ENABLED || 'true' }}
  PROMETHEUS_NAMESPACE: ${{ vars.PROMETHEUS_NAMESPACE || 'monitoring' }}
  PROMETHEUS_RETENTION: ${{ vars.PROMETHEUS_RETENTION || '15d' }}
  PROMETHEUS_STORAGE_SIZE: ${{ vars.PROMETHEUS_STORAGE_SIZE || '10Gi' }}
  PROMETHEUS_SCRAPE_INTERVAL: ${{ vars.PROMETHEUS_SCRAPE_INTERVAL || '15s' }}
  PROMETHEUS_SCRAPE_TIMEOUT: ${{ vars.PROMETHEUS_SCRAPE_TIMEOUT || '10s' }}
  
  # Monitoring - Grafana
  GRAFANA_ENABLED: ${{ vars.GRAFANA_ENABLED || 'true' }}
  GRAFANA_ADMIN_USER: ${{ vars.GRAFANA_ADMIN_USER || 'admin' }}
  GRAFANA_ADMIN_PASSWORD: ${{ secrets.GRAFANA_ADMIN_PASSWORD }}
  GRAFANA_PORT: ${{ vars.GRAFANA_PORT || '3000' }}
  GRAFANA_STORAGE_SIZE: ${{ vars.GRAFANA_STORAGE_SIZE || '5Gi' }}
  
  # Alerting Configuration
  ALERT_EMAIL_ENABLED: ${{ vars.ALERT_EMAIL_ENABLED || 'false' }}
  ALERT_EMAIL_TO: ${{ vars.ALERT_EMAIL_TO }}
  ALERT_EMAIL_FROM: ${{ vars.ALERT_EMAIL_FROM }}
  SMTP_HOST: ${{ vars.SMTP_HOST || 'smtp.gmail.com' }}
  SMTP_PORT: ${{ vars.SMTP_PORT || '587' }}
  SMTP_USERNAME: ${{ secrets.SMTP_USERNAME }}
  SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
  SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
  
  # Resource Limits & Requests - Application
  APP_CPU_REQUEST: ${{ vars.APP_CPU_REQUEST || '100m' }}
  APP_CPU_LIMIT: ${{ vars.APP_CPU_LIMIT || '500m' }}
  APP_MEMORY_REQUEST: ${{ vars.APP_MEMORY_REQUEST || '128Mi' }}
  APP_MEMORY_LIMIT: ${{ vars.APP_MEMORY_LIMIT || '512Mi' }}
  
  # Resource Limits & Requests - Prometheus
  PROMETHEUS_CPU_REQUEST: ${{ vars.PROMETHEUS_CPU_REQUEST || '500m' }}
  PROMETHEUS_CPU_LIMIT: ${{ vars.PROMETHEUS_CPU_LIMIT || '2000m' }}
  PROMETHEUS_MEMORY_REQUEST: ${{ vars.PROMETHEUS_MEMORY_REQUEST || '1Gi' }}
  PROMETHEUS_MEMORY_LIMIT: ${{ vars.PROMETHEUS_MEMORY_LIMIT || '4Gi' }}
  
  # Resource Limits & Requests - Grafana
  GRAFANA_CPU_REQUEST: ${{ vars.GRAFANA_CPU_REQUEST || '100m' }}
  GRAFANA_CPU_LIMIT: ${{ vars.GRAFANA_CPU_LIMIT || '500m' }}
  GRAFANA_MEMORY_REQUEST: ${{ vars.GRAFANA_MEMORY_REQUEST || '256Mi' }}
  GRAFANA_MEMORY_LIMIT: ${{ vars.GRAFANA_MEMORY_LIMIT || '1Gi' }}
  
  # AWS Configuration
  AWS_REGION: ${{ vars.AWS_REGION || 'us-east-1' }}
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  EKS_CLUSTER_NAME: ${{ vars.EKS_CLUSTER_NAME || 'devops-cluster' }}
  
  # Git Configuration
  GIT_AUTHOR_NAME: ${{ vars.GIT_AUTHOR_NAME || github.actor }}
  GIT_AUTHOR_EMAIL: ${{ vars.GIT_AUTHOR_EMAIL || format('{0}@users.noreply.github.com', github.actor) }}
  
  # GitHub Configuration
  GITHUB_USERNAME: ${{ github.actor }}
  GITHUB_EMAIL: ${{ vars.GITHUB_EMAIL || format('{0}@users.noreply.github.com', github.actor) }}
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  
  # Deployment Configuration
  DEPLOY_TARGET: ${{ inputs.deploy_target || vars.DEPLOY_TARGET || 'local' }}
  BUILD_PUSH: ${{ inputs.build_push || vars.BUILD_PUSH || 'true' }}
  CI: 'true'
  DRY_RUN: ${{ inputs.dry_run || 'false' }}
  
  # Minikube Configuration
  MINIKUBE_INGRESS: ${{ vars.MINIKUBE_INGRESS || 'true' }}
  MINIKUBE_MEMORY: ${{ vars.MINIKUBE_MEMORY || '4096' }}
  MINIKUBE_CPUS: ${{ vars.MINIKUBE_CPUS || '2' }}
  
  # Project Root
  PROJECT_ROOT: ${{ github.workspace }}

jobs:
  validate:
    name: Validate Configuration
    runs-on: ubuntu-latest
    outputs:
      deploy_target: ${{ steps.validate.outputs.deploy_target }}
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Validate configuration
        id: validate
        run: |
          echo "============================================================================"
          echo "DevOps Project Deployment - GitHub Actions"
          echo "============================================================================"
          echo "Repository: ${{ github.repository }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Commit: ${{ github.sha }}"
          echo "Actor: ${{ github.actor }}"
          echo "============================================================================"
          echo ""
          
          # Validate deployment target
          DEPLOY_TARGET="${{ env.DEPLOY_TARGET }}"
          if [[ "$DEPLOY_TARGET" != "local" && "$DEPLOY_TARGET" != "prod" ]]; then
            echo "âŒ Invalid DEPLOY_TARGET: $DEPLOY_TARGET"
            echo "Valid options: 'local' or 'prod'"
            exit 1
          fi
          
          echo "ðŸŽ¯ Deployment Target: $DEPLOY_TARGET"
          echo "deploy_target=$DEPLOY_TARGET" >> $GITHUB_OUTPUT
          
          # Check required secrets for DockerHub
          if [[ -z "${{ secrets.DOCKERHUB_USERNAME }}" ]]; then
            echo "âš ï¸  WARNING: DOCKERHUB_USERNAME secret not set"
          fi
          
          if [[ -z "${{ secrets.DOCKERHUB_PASSWORD }}" ]]; then
            echo "âš ï¸  WARNING: DOCKERHUB_PASSWORD secret not set"
          fi
          
          # Check required secrets for prod deployment
          if [[ "$DEPLOY_TARGET" == "prod" ]]; then
            if [[ -z "${{ secrets.AWS_ACCESS_KEY_ID }}" ]]; then
              echo "âŒ AWS_ACCESS_KEY_ID secret required for prod deployment"
              exit 1
            fi
            
            if [[ -z "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ]]; then
              echo "âŒ AWS_SECRET_ACCESS_KEY secret required for prod deployment"
              exit 1
            fi
          fi
          
          echo "âœ… Configuration validated"

  deploy-local:
    name: Deploy to Minikube (Local)
    runs-on: ubuntu-latest
    needs: validate
    if: needs.validate.outputs.deploy_target == 'local'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Login to DockerHub
        if: env.BUILD_PUSH == 'true'
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}
      
      - name: Install Minikube
        run: |
          echo "ðŸ“¥ Installing Minikube..."
          curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
          sudo install minikube-linux-amd64 /usr/local/bin/minikube
          rm minikube-linux-amd64
      
      - name: Start Minikube
        run: |
          echo "ðŸš€ Starting Minikube..."
          minikube start \
            --memory=${{ env.MINIKUBE_MEMORY }} \
            --cpus=${{ env.MINIKUBE_CPUS }} \
            --driver=docker
          
          echo "âœ… Minikube started"
          minikube status
      
      - name: Configure Docker environment
        run: |
          echo "ðŸ³ Configuring Docker environment..."
          eval "$(minikube docker-env)"
      
      - name: Enable Minikube Ingress
        if: env.MINIKUBE_INGRESS == 'true'
        run: |
          echo "ðŸŒ Enabling Ingress addon..."
          minikube addons enable ingress
          echo "âœ… Ingress enabled"
      
      - name: Install kubectl
        run: |
          echo "ðŸ“¥ Installing kubectl..."
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          sudo install kubectl /usr/local/bin/kubectl
          rm kubectl
          kubectl version --client
      
      - name: Check prerequisites
        run: |
          echo "ðŸ” Checking prerequisites..."
          echo "Tool versions:"
          docker --version
          kubectl version --client
          minikube version
          echo "âœ… All prerequisites met"
      
      - name: Load deployment scripts
        run: |
          echo "ðŸ“‚ Loading deployment scripts..."
          # Make all scripts executable
          chmod +x app/build_and_push_image.sh
          chmod +x app/configure_dockerhub_username.sh
          chmod +x kubernetes/deploy_kubernetes.sh
          chmod +x monitoring/deploy_monitoring.sh
          echo "âœ… Scripts loaded and made executable"
      
      - name: Configure DockerHub
        run: |
          echo "âš™ï¸  Configuring DockerHub..."
          source ./app/configure_dockerhub_username.sh
          configure_dockerhub_username
      
      - name: Build and Push Docker Image
        if: env.BUILD_PUSH == 'true'
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_PASSWORD: ${{ secrets.DOCKERHUB_PASSWORD }}
        run: |
          echo "ðŸ”¨ Building and pushing Docker image..."
          eval "$(minikube docker-env)"
          source ./app/build_and_push_image.sh
          build_and_push_image
      
      - name: Build Docker Image Locally
        if: env.BUILD_PUSH != 'true'
        run: |
          echo "ðŸ”¨ Building Docker image locally..."
          eval "$(minikube docker-env)"
          docker build -t ${{ env.APP_NAME }}:latest ./app
      
      - name: Deploy Kubernetes Resources
        run: |
          echo "ðŸ“¦ Deploying Kubernetes resources..."
          source ./kubernetes/deploy_kubernetes.sh
          deploy_kubernetes local
      
      - name: Deploy Monitoring Stack
        run: |
          echo "ðŸ“Š Deploying monitoring stack..."
          source ./monitoring/deploy_monitoring.sh
          deploy_monitoring
      
      - name: Get Deployment Info
        id: deployment_info
        run: |
          MINIKUBE_IP=$(minikube ip)
          NODE_PORT=$(kubectl get svc "${{ env.APP_NAME }}-service" -n "${{ env.NAMESPACE }}" -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "N/A")
          
          echo "minikube_ip=$MINIKUBE_IP" >> $GITHUB_OUTPUT
          echo "node_port=$NODE_PORT" >> $GITHUB_OUTPUT
      
      - name: Deployment Summary
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "  âœ… Application deployed to Minikube"
          echo ""
          echo "  ðŸŒ Minikube IP:   ${{ steps.deployment_info.outputs.minikube_ip }}"
          echo "  ðŸ”Œ Node Port:     ${{ steps.deployment_info.outputs.node_port }}"
          echo "  ðŸ“± App URL:       http://${{ steps.deployment_info.outputs.minikube_ip }}:${{ steps.deployment_info.outputs.node_port }}"
          echo ""
          echo "  ðŸ“Š View logs:     kubectl logs -f deployment/${{ env.APP_NAME }} -n ${{ env.NAMESPACE }}"
          echo "  ðŸ” Check pods:    kubectl get pods -n ${{ env.NAMESPACE }}"
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      
      - name: Upload Minikube Logs
        if: always()
        run: |
          mkdir -p logs
          minikube logs > logs/minikube.log 2>&1 || true
          kubectl get all -A > logs/kubectl-all.log 2>&1 || true
      
      - name: Upload logs as artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: minikube-logs
          path: logs/
          retention-days: 7

  deploy-prod:
    name: Deploy to AWS EKS (Production)
    runs-on: ubuntu-latest
    needs: validate
    if: needs.validate.outputs.deploy_target == 'prod'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Install Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: latest
      
      - name: Install kubectl
        run: |
          echo "ðŸ“¥ Installing kubectl..."
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          sudo install kubectl /usr/local/bin/kubectl
          rm kubectl
          kubectl version --client
      
      - name: Check prerequisites
        run: |
          echo "ðŸ” Checking prerequisites..."
          echo "Tool versions:"
          docker --version
          kubectl version --client
          terraform --version
          aws --version
          echo "âœ… All prerequisites met"
      
      - name: Deploy infrastructure with Terraform
        working-directory: infra/terraform
        run: |
          echo "ðŸ—ï¸  Deploying infrastructure with Terraform..."
          terraform init -upgrade
          
          if [[ "${{ env.DRY_RUN }}" == "true" ]]; then
            echo "ðŸ” Dry run mode - planning only..."
            terraform plan
          else
            terraform apply -auto-approve
          fi
      
      - name: Configure kubectl context
        if: env.DRY_RUN != 'true'
        working-directory: infra/terraform
        run: |
          echo "âš™ï¸  Configuring kubectl context..."
          REGION=$(terraform output -raw region)
          CLUSTER_NAME=$(terraform output -raw cluster_name)
          
          aws eks update-kubeconfig \
            --region "$REGION" \
            --name "$CLUSTER_NAME"
          
          echo "âœ… kubectl configured for EKS cluster: $CLUSTER_NAME"
      
      - name: Load deployment scripts
        run: |
          echo "ðŸ“‚ Loading deployment scripts..."
          # Make all scripts executable
          chmod +x app/build_and_push_image.sh
          chmod +x app/configure_dockerhub_username.sh
          chmod +x kubernetes/deploy_kubernetes.sh
          chmod +x monitoring/deploy_monitoring.sh
          echo "âœ… Scripts loaded and made executable"
      
      - name: Configure DockerHub
        run: |
          echo "âš™ï¸  Configuring DockerHub..."
          source ./app/configure_dockerhub_username.sh
          configure_dockerhub_username
      
      - name: Build and Push Docker Image
        if: env.BUILD_PUSH == 'true'
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_PASSWORD: ${{ secrets.DOCKERHUB_PASSWORD }}
        run: |
          eval "$(minikube docker-env)"
          source ./app/build_and_push_image.sh
          build_and_push_image
      
      - name: Deploy Kubernetes Resources
        if: env.DRY_RUN != 'true'
        run: |
          echo "ðŸ“¦ Deploying Kubernetes resources..."
          source ./kubernetes/deploy_kubernetes.sh
          deploy_kubernetes prod
      
      - name: Deploy Monitoring Stack
        if: env.DRY_RUN != 'true'
        run: |
          echo "ðŸ“Š Deploying monitoring stack..."
          source ./monitoring/deploy_monitoring.sh
          deploy_monitoring
      
      - name: Get Deployment Info
        if: env.DRY_RUN != 'true'
        id: deployment_info
        run: |
          LOAD_BALANCER=$(kubectl get svc "${{ env.APP_NAME }}-service" -n "${{ env.NAMESPACE }}" -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "Pending")
          INGRESS_HOST=$(kubectl get ingress -n "${{ env.NAMESPACE }}" -o jsonpath='{.items[0].spec.rules[0].host}' 2>/dev/null || echo "N/A")
          
          echo "load_balancer=$LOAD_BALANCER" >> $GITHUB_OUTPUT
          echo "ingress_host=$INGRESS_HOST" >> $GITHUB_OUTPUT
      
      - name: Deployment Summary
        if: env.DRY_RUN != 'true'
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "  âœ… Application deployed to AWS EKS"
          echo ""
          echo "  â˜ï¸  Cluster:      ${{ env.EKS_CLUSTER_NAME }}"
          echo "  ðŸŒ Region:       ${{ env.AWS_REGION }}"
          echo "  ðŸ“¦ Namespace:    ${{ env.NAMESPACE }}"
          echo ""
          if [[ "${{ steps.deployment_info.outputs.load_balancer }}" != "Pending" ]]; then
            echo "  ðŸŒ LoadBalancer: http://${{ steps.deployment_info.outputs.load_balancer }}"
          else
            echo "  ðŸŒ LoadBalancer: â³ Pending..."
          fi
          echo "  ðŸ”— Ingress Host: ${{ steps.deployment_info.outputs.ingress_host }}"
          echo ""
          echo "  ðŸ“Š View logs:    kubectl logs -f deployment/${{ env.APP_NAME }} -n ${{ env.NAMESPACE }}"
          echo "  ðŸ” Check pods:   kubectl get pods -n ${{ env.NAMESPACE }}"
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      
      - name: Upload Deployment Logs
        if: always() && env.DRY_RUN != 'true'
        run: |
          mkdir -p logs
          kubectl get all -A > logs/kubectl-all.log 2>&1 || true
          kubectl describe pods -n ${{ env.NAMESPACE }} > logs/pods-describe.log 2>&1 || true
      
      - name: Upload logs as artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: eks-deployment-logs
          path: logs/
          retention-days: 7