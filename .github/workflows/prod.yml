name: Production Deployment Pipeline

on:
  push:
    branches:
      - main
      - master
  pull_request:
    branches:
      - main
      - master
  workflow_dispatch:
    inputs:
      deploy_target:
        description: 'Deployment target (local/prod)'
        required: true
        default: 'local'
        type: choice
        options:
          - local
          - prod
      build_push:
        description: 'Build and push Docker image'
        required: true
        default: 'true'
        type: boolean
      dry_run:
        description: 'Dry run mode (test without deployment)'
        required: false
        default: false
        type: boolean

env:
  # Project Configuration (from .env or secrets)
  APP_NAME: ${{ vars.APP_NAME || 'devops-app' }}
  NAMESPACE: ${{ vars.NAMESPACE || 'devops-app' }}
  APP_PORT: ${{ vars.APP_PORT || '3000' }}
  REPLICAS: ${{ vars.REPLICAS || '2' }}
  MIN_REPLICAS: ${{ vars.MIN_REPLICAS || '2' }}
  MAX_REPLICAS: ${{ vars.MAX_REPLICAS || '10' }}
  CPU_TARGET_UTILIZATION: ${{ vars.CPU_TARGET_UTILIZATION || '70' }}
  MEMORY_TARGET_UTILIZATION: ${{ vars.MEMORY_TARGET_UTILIZATION || '80' }}
  
  # Docker Configuration
  DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME || vars.DOCKERHUB_USERNAME }}
  DOCKER_IMAGE_TAG: ${{ vars.DOCKER_IMAGE_TAG || 'latest' }}
  IMAGE_TAG: ${{ vars.IMAGE_TAG || 'latest' }}
  
  # Ingress Configuration
  INGRESS_ENABLED: ${{ vars.INGRESS_ENABLED || 'true' }}
  INGRESS_HOST: ${{ vars.INGRESS_HOST || 'devops-app.local' }}
  INGRESS_CLASS: ${{ vars.INGRESS_CLASS || 'nginx' }}
  TLS_ENABLED: ${{ vars.TLS_ENABLED || 'false' }}
  TLS_SECRET_NAME: ${{ vars.TLS_SECRET_NAME || 'devops-app-tls' }}
  
  # Database Configuration
  DB_HOST: ${{ vars.DB_HOST || 'localhost' }}
  DB_PORT: ${{ vars.DB_PORT || '5432' }}
  DB_NAME: ${{ vars.DB_NAME || 'devopsdb' }}
  DB_USERNAME: ${{ secrets.DB_USERNAME || 'dbuser' }}
  
  # Monitoring - Prometheus
  PROMETHEUS_ENABLED: ${{ vars.PROMETHEUS_ENABLED || 'true' }}
  PROMETHEUS_NAMESPACE: ${{ vars.PROMETHEUS_NAMESPACE || 'monitoring' }}
  PROMETHEUS_RETENTION: ${{ vars.PROMETHEUS_RETENTION || '15d' }}
  PROMETHEUS_STORAGE_SIZE: ${{ vars.PROMETHEUS_STORAGE_SIZE || '10Gi' }}
  PROMETHEUS_SCRAPE_INTERVAL: ${{ vars.PROMETHEUS_SCRAPE_INTERVAL || '15s' }}
  PROMETHEUS_SCRAPE_TIMEOUT: ${{ vars.PROMETHEUS_SCRAPE_TIMEOUT || '10s' }}
  
  # Monitoring - Grafana
  GRAFANA_ENABLED: ${{ vars.GRAFANA_ENABLED || 'true' }}
  GRAFANA_ADMIN_USER: ${{ vars.GRAFANA_ADMIN_USER || 'admin' }}
  GRAFANA_PORT: ${{ vars.GRAFANA_PORT || '3000' }}
  GRAFANA_STORAGE_SIZE: ${{ vars.GRAFANA_STORAGE_SIZE || '5Gi' }}
  
  # Resource Limits
  APP_CPU_REQUEST: ${{ vars.APP_CPU_REQUEST || '100m' }}
  APP_CPU_LIMIT: ${{ vars.APP_CPU_LIMIT || '500m' }}
  APP_MEMORY_REQUEST: ${{ vars.APP_MEMORY_REQUEST || '128Mi' }}
  APP_MEMORY_LIMIT: ${{ vars.APP_MEMORY_LIMIT || '512Mi' }}
  
  PROMETHEUS_CPU_REQUEST: ${{ vars.PROMETHEUS_CPU_REQUEST || '500m' }}
  PROMETHEUS_CPU_LIMIT: ${{ vars.PROMETHEUS_CPU_LIMIT || '2000m' }}
  PROMETHEUS_MEMORY_REQUEST: ${{ vars.PROMETHEUS_MEMORY_REQUEST || '1Gi' }}
  PROMETHEUS_MEMORY_LIMIT: ${{ vars.PROMETHEUS_MEMORY_LIMIT || '4Gi' }}
  
  GRAFANA_CPU_REQUEST: ${{ vars.GRAFANA_CPU_REQUEST || '100m' }}
  GRAFANA_CPU_LIMIT: ${{ vars.GRAFANA_CPU_LIMIT || '500m' }}
  GRAFANA_MEMORY_REQUEST: ${{ vars.GRAFANA_MEMORY_REQUEST || '256Mi' }}
  GRAFANA_MEMORY_LIMIT: ${{ vars.GRAFANA_MEMORY_LIMIT || '1Gi' }}
  
  # AWS Configuration
  AWS_REGION: ${{ vars.AWS_REGION || secrets.AWS_REGION || 'us-east-1' }}
  EKS_CLUSTER_NAME: ${{ vars.EKS_CLUSTER_NAME || 'devops-cluster' }}
  
  # Git Configuration
  GIT_AUTHOR_NAME: ${{ vars.GIT_AUTHOR_NAME || github.actor }}
  GIT_AUTHOR_EMAIL: ${{ vars.GIT_AUTHOR_EMAIL || format('{0}@users.noreply.github.com', github.actor) }}
  
  # Deployment Configuration
  DEPLOY_TARGET: ${{ github.event.inputs.deploy_target || vars.DEPLOY_TARGET || 'local' }}
  BUILD_PUSH: ${{ github.event.inputs.build_push || vars.BUILD_PUSH || 'false' }}
  DRY_RUN: ${{ github.event.inputs.dry_run || vars.DRY_RUN || 'false' }}
  CI: true
  
  # Minikube Configuration
  MINIKUBE_INGRESS: ${{ vars.MINIKUBE_INGRESS || 'true' }}
  MINIKUBE_MEMORY: ${{ vars.MINIKUBE_MEMORY || '4096' }}
  MINIKUBE_CPUS: ${{ vars.MINIKUBE_CPUS || '2' }}
  
  # Alerting Configuration
  ALERT_EMAIL_ENABLED: ${{ vars.ALERT_EMAIL_ENABLED || 'false' }}
  SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL || vars.SLACK_WEBHOOK_URL }}

jobs:
  validate-config:
    name: ðŸ” Validate Configuration
    runs-on: ubuntu-latest
    outputs:
      deploy_target: ${{ steps.set-target.outputs.deploy_target }}
      build_push: ${{ steps.set-build.outputs.build_push }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set deployment target
        id: set-target
        run: |
          TARGET="${{ env.DEPLOY_TARGET }}"
          echo "deploy_target=${TARGET}" >> $GITHUB_OUTPUT
          echo "ðŸŽ¯ Deployment Target: ${TARGET}"
      
      - name: Set build/push flag
        id: set-build
        run: |
          BUILD="${{ env.BUILD_PUSH }}"
          echo "build_push=${BUILD}" >> $GITHUB_OUTPUT
          echo "ðŸ”¨ Build & Push: ${BUILD}"
      
      - name: Validate required secrets (prod only)
        if: env.DEPLOY_TARGET == 'prod'
        run: |
          echo "ðŸ” Validating required secrets for production deployment..."
          
          missing_secrets=()
          
          # Check Docker credentials
          if [ -z "${{ secrets.DOCKERHUB_USERNAME }}" ]; then
            missing_secrets+=("DOCKERHUB_USERNAME")
          fi
          if [ -z "${{ secrets.DOCKERHUB_PASSWORD }}" ]; then
            missing_secrets+=("DOCKERHUB_PASSWORD")
          fi
          
          # Check AWS credentials
          if [ -z "${{ secrets.AWS_ACCESS_KEY_ID }}" ]; then
            missing_secrets+=("AWS_ACCESS_KEY_ID")
          fi
          if [ -z "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ]; then
            missing_secrets+=("AWS_SECRET_ACCESS_KEY")
          fi
          
          # Check database credentials
          if [ -z "${{ secrets.DB_PASSWORD }}" ]; then
            missing_secrets+=("DB_PASSWORD")
          fi
          
          if [ ${#missing_secrets[@]} -gt 0 ]; then
            echo "âŒ Missing required secrets:"
            printf '   - %s\n' "${missing_secrets[@]}"
            echo ""
            echo "Please add these secrets in:"
            echo "Repository â†’ Settings â†’ Secrets and variables â†’ Actions"
            exit 1
          else
            echo "âœ… All required secrets are present"
          fi
      
      - name: Validate configuration values
        run: |
          echo "ðŸ” Validating configuration values..."
          
          # Validate deployment target
          if [[ "${{ env.DEPLOY_TARGET }}" != "local" && "${{ env.DEPLOY_TARGET }}" != "prod" ]]; then
            echo "âŒ Invalid DEPLOY_TARGET: ${{ env.DEPLOY_TARGET }}"
            echo "Valid options: 'local' or 'prod'"
            exit 1
          fi
          
          # Validate numeric values
          if ! [[ "${{ env.REPLICAS }}" =~ ^[0-9]+$ ]]; then
            echo "âŒ REPLICAS must be numeric"
            exit 1
          fi
          
          if ! [[ "${{ env.APP_PORT }}" =~ ^[0-9]+$ ]]; then
            echo "âŒ APP_PORT must be numeric"
            exit 1
          fi
          
          echo "âœ… Configuration validation passed"

  build-and-push:
    name: ðŸ”¨ Build & Push Docker Image
    needs: validate-config
    runs-on: ubuntu-latest
    if: needs.validate-config.outputs.build_push == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME || vars.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}
      
      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKERHUB_USERNAME }}/${{ env.APP_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value=${{ env.DOCKER_IMAGE_TAG }}
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./app
          file: ./app/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            APP_PORT=${{ env.APP_PORT }}
            NODE_ENV=production
      
      - name: Image digest
        run: |
          echo "âœ… Docker image built and pushed successfully"
          echo "ðŸ“¦ Image: ${{ env.DOCKERHUB_USERNAME }}/${{ env.APP_NAME }}:${{ env.DOCKER_IMAGE_TAG }}"

  deploy-local:
    name: ðŸš€ Deploy to Minikube (Local)
    needs: [validate-config, build-and-push]
    runs-on: ubuntu-latest
    if: |
      always() && 
      needs.validate-config.result == 'success' && 
      needs.validate-config.outputs.deploy_target == 'local' &&
      (needs.build-and-push.result == 'success' || needs.build-and-push.result == 'skipped')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Start Minikube
        uses: medyagh/setup-minikube@latest
        with:
          memory: ${{ env.MINIKUBE_MEMORY }}
          cpus: ${{ env.MINIKUBE_CPUS }}
          driver: docker
          kubernetes-version: stable
      
      - name: Verify Minikube status
        run: |
          echo "ðŸ” Checking Minikube status..."
          minikube status
          kubectl cluster-info
          kubectl get nodes
      
      - name: Enable Minikube addons
        if: env.MINIKUBE_INGRESS == 'true'
        run: |
          echo "ðŸŒ Enabling Ingress addon..."
          minikube addons enable ingress
          minikube addons enable metrics-server
      
      - name: Configure Docker environment for Minikube
        run: |
          echo "ðŸ³ Configuring Docker environment..."
          eval $(minikube docker-env)
          docker ps
      
      - name: Build Docker image in Minikube (if not pushing)
        if: needs.validate-config.outputs.build_push != 'true'
        run: |
          echo "ðŸ”¨ Building Docker image locally in Minikube..."
          eval $(minikube docker-env)
          docker build -t ${{ env.APP_NAME }}:latest ./app
          docker images | grep ${{ env.APP_NAME }}
      
      - name: Pull Docker image (if pushed to registry)
        if: needs.validate-config.outputs.build_push == 'true'
        run: |
          echo "ðŸ“¥ Pulling Docker image from registry..."
          eval $(minikube docker-env)
          docker pull ${{ env.DOCKERHUB_USERNAME }}/${{ env.APP_NAME }}:${{ env.DOCKER_IMAGE_TAG }}
          docker tag ${{ env.DOCKERHUB_USERNAME }}/${{ env.APP_NAME }}:${{ env.DOCKER_IMAGE_TAG }} ${{ env.APP_NAME }}:latest
      
      - name: Create namespace
        run: |
          echo "ðŸ“¦ Creating namespace..."
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
      
      - name: Create Kubernetes secrets
        run: |
          echo "ðŸ” Creating Kubernetes secrets..."
          kubectl create secret generic app-secrets \
            --from-literal=db-password='${{ secrets.DB_PASSWORD || 'SecurePassword123!' }}' \
            --from-literal=jwt-secret='${{ secrets.JWT_SECRET || 'your-super-secret-jwt-key' }}' \
            --from-literal=api-key='${{ secrets.API_KEY || 'your-api-key-here' }}' \
            --from-literal=session-secret='${{ secrets.SESSION_SECRET || 'your-session-secret-here' }}' \
            --namespace=${{ env.NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -
      
      - name: Create ConfigMap
        run: |
          echo "âš™ï¸  Creating ConfigMap..."
          kubectl create configmap app-config \
            --from-literal=app-name='${{ env.APP_NAME }}' \
            --from-literal=app-port='${{ env.APP_PORT }}' \
            --from-literal=db-host='${{ env.DB_HOST }}' \
            --from-literal=db-port='${{ env.DB_PORT }}' \
            --from-literal=db-name='${{ env.DB_NAME }}' \
            --from-literal=db-username='${{ env.DB_USERNAME }}' \
            --namespace=${{ env.NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -
      - name: Install kustomize
        run: |
          echo "ðŸ“¦ Installing kustomize..."
          curl -s https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh | bash
          sudo mv kustomize /usr/local/bin/
          kustomize version

      - name: Deploy application with Kustomize
        run: |
          echo "ðŸ“¦ Deploying application with Kustomize..."
          
          # Set image in kustomization
          cd kubernetes/overlays/local
          kustomize edit set image ${{ env.APP_NAME }}=${{ env.APP_NAME }}:latest
          kustomize edit set namespace ${{ env.NAMESPACE }}
          
          # Apply with kustomize
          kubectl apply -k .
          
          echo "âœ… Application deployed"
      
      - name: Wait for deployment rollout
        run: |
          echo "â³ Waiting for deployment to be ready..."
          kubectl rollout status deployment/${{ env.APP_NAME }} \
            -n ${{ env.NAMESPACE }} \
            --timeout=5m
      
      - name: Deploy monitoring stack
        if: env.PROMETHEUS_ENABLED == 'true' || env.GRAFANA_ENABLED == 'true'
        run: |
          echo "ðŸ“Š Deploying monitoring stack..."
          
          # Create monitoring namespace
          kubectl create namespace ${{ env.PROMETHEUS_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
          
          # Deploy Prometheus
          if [ "${{ env.PROMETHEUS_ENABLED }}" == "true" ]; then
            echo "ðŸ“ˆ Deploying Prometheus..."
            kubectl apply -f monitoring/prometheus_grafana/prometheus.yaml -n ${{ env.PROMETHEUS_NAMESPACE }}
            kubectl apply -f monitoring/kube-state-metrics/ -n ${{ env.PROMETHEUS_NAMESPACE }}
            kubectl apply -f monitoring/node-exporter/daemonset.yaml -n ${{ env.PROMETHEUS_NAMESPACE }}
          fi
          
          # Deploy Grafana
          if [ "${{ env.GRAFANA_ENABLED }}" == "true" ]; then
            echo "ðŸ“Š Deploying Grafana..."
            
            # Create Grafana admin secret
            kubectl create secret generic grafana-admin \
              --from-literal=admin-user='${{ env.GRAFANA_ADMIN_USER }}' \
              --from-literal=admin-password='${{ secrets.GRAFANA_ADMIN_PASSWORD || 'admin123' }}' \
              --namespace=${{ env.PROMETHEUS_NAMESPACE }} \
              --dry-run=client -o yaml | kubectl apply -f -
            
            kubectl apply -f monitoring/prometheus_grafana/dashboard-configmap.yaml -n ${{ env.PROMETHEUS_NAMESPACE }}
            kubectl apply -f monitoring/prometheus_grafana/grafana.yaml -n ${{ env.PROMETHEUS_NAMESPACE }}
          fi
          
          echo "âœ… Monitoring stack deployed"
      
      - name: Get service information
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "  âœ… Application deployed to Minikube"
          echo ""
          
          MINIKUBE_IP=$(minikube ip)
          NODE_PORT=$(kubectl get svc ${{ env.APP_NAME }}-service -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.ports[0].nodePort}')
          
          echo "  ðŸŒ App URL:       http://${MINIKUBE_IP}:${NODE_PORT}"
          echo "  ðŸ“¦ Namespace:     ${{ env.NAMESPACE }}"
          echo "  ðŸ”„ Replicas:      ${{ env.REPLICAS }}"
          echo ""
          echo "  ðŸ“Š Monitoring:"
          if [ "${{ env.PROMETHEUS_ENABLED }}" == "true" ]; then
            PROM_PORT=$(kubectl get svc prometheus -n ${{ env.PROMETHEUS_NAMESPACE }} -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "N/A")
            echo "     Prometheus:    http://${MINIKUBE_IP}:${PROM_PORT}"
          fi
          if [ "${{ env.GRAFANA_ENABLED }}" == "true" ]; then
            GRAFANA_PORT=$(kubectl get svc grafana -n ${{ env.PROMETHEUS_NAMESPACE }} -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "N/A")
            echo "     Grafana:       http://${MINIKUBE_IP}:${GRAFANA_PORT}"
          fi
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      
      - name: Display pods status
        if: always()
        run: |
          echo ""
          echo "ðŸ“‹ Pods in ${{ env.NAMESPACE }} namespace:"
          kubectl get pods -n ${{ env.NAMESPACE }}
          echo ""
          echo "ðŸ“‹ Pods in ${{ env.PROMETHEUS_NAMESPACE }} namespace:"
          kubectl get pods -n ${{ env.PROMETHEUS_NAMESPACE }} || true
      
      - name: Show recent logs
        if: always()
        run: |
          echo ""
          echo "ðŸ“œ Recent application logs:"
          kubectl logs -n ${{ env.NAMESPACE }} -l app=${{ env.APP_NAME }} --tail=50 || true

  deploy-prod:
    name: â˜ï¸ Deploy to AWS EKS (Production)
    needs: [validate-config, build-and-push]
    runs-on: ubuntu-latest
    if: |
      always() && 
      needs.validate-config.result == 'success' && 
      needs.validate-config.outputs.deploy_target == 'prod' &&
      needs.build-and-push.result == 'success'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: latest
      
      - name: Terraform Init
        run: |
          echo "ðŸ—ï¸  Initializing Terraform..."
          cd infra/terraform
          terraform init -upgrade
      
      - name: Terraform Plan
        run: |
          echo "ðŸ“‹ Planning Terraform changes..."
          cd infra/terraform
          terraform plan -out=tfplan
      
      - name: Terraform Apply
        if: env.DRY_RUN != 'true'
        run: |
          echo "ðŸš€ Applying Terraform changes..."
          cd infra/terraform
          terraform apply -auto-approve tfplan
      
      - name: Get EKS cluster info
        run: |
          echo "âš™ï¸  Getting EKS cluster information..."
          cd infra/terraform
          echo "CLUSTER_NAME=$(terraform output -raw cluster_name)" >> $GITHUB_ENV
          echo "CLUSTER_REGION=$(terraform output -raw region)" >> $GITHUB_ENV
      
      - name: Update kubeconfig
        run: |
          echo "âš™ï¸  Configuring kubectl for EKS..."
          aws eks update-kubeconfig \
            --region ${{ env.CLUSTER_REGION }} \
            --name ${{ env.CLUSTER_NAME }}
          
          kubectl cluster-info
          kubectl get nodes
      
      - name: Create namespace
        run: |
          echo "ðŸ“¦ Creating namespace..."
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
      
      - name: Create Kubernetes secrets
        run: |
          echo "ðŸ” Creating Kubernetes secrets..."
          kubectl create secret generic app-secrets \
            --from-literal=db-password='${{ secrets.DB_PASSWORD }}' \
            --from-literal=jwt-secret='${{ secrets.JWT_SECRET }}' \
            --from-literal=api-key='${{ secrets.API_KEY }}' \
            --from-literal=session-secret='${{ secrets.SESSION_SECRET }}' \
            --namespace=${{ env.NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -
          
          # Docker registry secret for pulling images
          kubectl create secret docker-registry dockerhub-secret \
            --docker-server=https://index.docker.io/v1/ \
            --docker-username=${{ secrets.DOCKERHUB_USERNAME }} \
            --docker-password=${{ secrets.DOCKERHUB_PASSWORD }} \
            --namespace=${{ env.NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -
      
      - name: Create ConfigMap
        run: |
          echo "âš™ï¸  Creating ConfigMap..."
          kubectl create configmap app-config \
            --from-literal=app-name='${{ env.APP_NAME }}' \
            --from-literal=app-port='${{ env.APP_PORT }}' \
            --from-literal=db-host='${{ env.DB_HOST }}' \
            --from-literal=db-port='${{ env.DB_PORT }}' \
            --from-literal=db-name='${{ env.DB_NAME }}' \
            --from-literal=db-username='${{ env.DB_USERNAME }}' \
            --namespace=${{ env.NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -
      
      - name: Deploy application with Kustomize
        run: |
          echo "ðŸ“¦ Deploying application to production..."
          
          cd kubernetes/overlays/prod
          kustomize edit set image ${{ env.APP_NAME }}=${{ env.DOCKERHUB_USERNAME }}/${{ env.APP_NAME }}:${{ env.DOCKER_IMAGE_TAG }}
          kustomize edit set namespace ${{ env.NAMESPACE }}
          
          kubectl apply -k .
          
          echo "âœ… Application deployed to production"
      
      - name: Wait for deployment rollout
        run: |
          echo "â³ Waiting for deployment to be ready..."
          kubectl rollout status deployment/${{ env.APP_NAME }} \
            -n ${{ env.NAMESPACE }} \
            --timeout=10m
      
      - name: Deploy monitoring stack
        if: env.PROMETHEUS_ENABLED == 'true' || env.GRAFANA_ENABLED == 'true'
        run: |
          echo "ðŸ“Š Deploying monitoring stack..."
          
          kubectl create namespace ${{ env.PROMETHEUS_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
          
          if [ "${{ env.PROMETHEUS_ENABLED }}" == "true" ]; then
            echo "ðŸ“ˆ Deploying Prometheus..."
            kubectl apply -f monitoring/prometheus_grafana/prometheus.yaml -n ${{ env.PROMETHEUS_NAMESPACE }}
            kubectl apply -f monitoring/kube-state-metrics/ -n ${{ env.PROMETHEUS_NAMESPACE }}
            kubectl apply -f monitoring/node-exporter/daemonset.yaml -n ${{ env.PROMETHEUS_NAMESPACE }}
          fi
          
          if [ "${{ env.GRAFANA_ENABLED }}" == "true" ]; then
            echo "ðŸ“Š Deploying Grafana..."
            
            kubectl create secret generic grafana-admin \
              --from-literal=admin-user='${{ env.GRAFANA_ADMIN_USER }}' \
              --from-literal=admin-password='${{ secrets.GRAFANA_ADMIN_PASSWORD }}' \
              --namespace=${{ env.PROMETHEUS_NAMESPACE }} \
              --dry-run=client -o yaml | kubectl apply -f -
            
            kubectl apply -f monitoring/prometheus_grafana/dashboard-configmap.yaml -n ${{ env.PROMETHEUS_NAMESPACE }}
            kubectl apply -f monitoring/prometheus_grafana/grafana.yaml -n ${{ env.PROMETHEUS_NAMESPACE }}
          fi
      
      - name: Deploy ArgoCD (if configured)
        if: vars.ARGOCD_ENABLED == 'true'
        run: |
          echo "ðŸ”„ Deploying ArgoCD..."
          
          kubectl create namespace argocd --dry-run=client -o yaml | kubectl apply -f -
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
          
          # Wait for ArgoCD to be ready
          kubectl wait --for=condition=available --timeout=300s \
            deployment/argocd-server -n argocd
          
          # Apply ArgoCD application
          if [ -f cicd/argocd/application.yaml ]; then
            kubectl apply -f cicd/argocd/application.yaml -n argocd
          fi
          
          echo "âœ… ArgoCD deployed"
      
      - name: Get service endpoints
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "  âœ… Application deployed to AWS EKS"
          echo ""
          echo "  â˜ï¸  Cluster:      ${{ env.CLUSTER_NAME }}"
          echo "  ðŸŒ Region:       ${{ env.CLUSTER_REGION }}"
          echo "  ðŸ“¦ Namespace:    ${{ env.NAMESPACE }}"
          echo ""
          
          # Get LoadBalancer endpoint if exists
          LB_ENDPOINT=$(kubectl get svc ${{ env.APP_NAME }}-service -n ${{ env.NAMESPACE }} \
            -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "Pending...")
          
          if [ "$LB_ENDPOINT" != "Pending..." ]; then
            echo "  ðŸŒ LoadBalancer: http://${LB_ENDPOINT}"
          else
            echo "  â³ LoadBalancer endpoint is being provisioned..."
            echo "     Run: kubectl get svc -n ${{ env.NAMESPACE }}"
          fi
          
          # Get Ingress endpoint if exists
          if [ "${{ env.INGRESS_ENABLED }}" == "true" ]; then
            INGRESS_ENDPOINT=$(kubectl get ingress ${{ env.APP_NAME }}-ingress -n ${{ env.NAMESPACE }} \
              -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "Pending...")
            
            if [ "$INGRESS_ENDPOINT" != "Pending..." ]; then
              echo "  ðŸšª Ingress:      http://${INGRESS_ENDPOINT}"
            fi
          fi
          
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      
      - name: Display deployment status
        if: always()
        run: |
          echo ""
          echo "ðŸ“‹ Deployment status:"
          kubectl get deployments -n ${{ env.NAMESPACE }}
          echo ""
          echo "ðŸ“‹ Pods:"
          kubectl get pods -n ${{ env.NAMESPACE }}
          echo ""
          echo "ðŸ“‹ Services:"
          kubectl get svc -n ${{ env.NAMESPACE }}
      
      - name: Send Slack notification
        if: always() && env.SLACK_WEBHOOK_URL != ''
        run: |
          STATUS="${{ job.status }}"
          COLOR="good"
          if [ "$STATUS" != "success" ]; then
            COLOR="danger"
          fi
          
          curl -X POST ${{ env.SLACK_WEBHOOK_URL }} \
            -H 'Content-Type: application/json' \
            -d "{
              \"attachments\": [{
                \"color\": \"${COLOR}\",
                \"title\": \"Deployment to Production\",
                \"text\": \"Status: ${STATUS}\nCluster: ${{ env.CLUSTER_NAME }}\nNamespace: ${{ env.NAMESPACE }}\",
                \"footer\": \"GitHub Actions\",
                \"ts\": $(date +%s)
              }]
            }"

  post-deployment-tests:
    name: ðŸ§ª Post-Deployment Tests
    needs: [deploy-local, deploy-prod]
    runs-on: ubuntu-latest
    if: always() && (needs.deploy-local.result == 'success' || needs.deploy-prod.result == 'success')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup test environment
        run: |
          echo "ðŸ§ª Setting up test environment..."
          # Add any test setup here
      
      - name: Health check placeholder
        run: |
          echo "âœ… Health checks would run here"
          echo "   - API endpoint tests"
          echo "   - Database connectivity"
          echo "   - Service mesh verification"
          echo ""
          echo "Implement actual health checks based on your application requirements"

  summary:
    name: ðŸ“Š Deployment Summary
    needs: [validate-config, build-and-push, deploy-local, deploy-prod, post-deployment-tests]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Generate summary
        run: |
          echo "# ðŸš€ Deployment Pipeline Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Configuration" >> $GITHUB_STEP_SUMMARY
          echo "- **Target**: ${{ needs.validate-config.outputs.deploy_target }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Build & Push**: ${{ needs.validate-config.outputs.build_push }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Application**: ${{ env.APP_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Namespace**: ${{ env.NAMESPACE }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Job Status" >> $GITHUB_STEP_SUMMARY
          echo "| Job | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Validate Config | ${{ needs.validate-config.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Build & Push | ${{ needs.build-and-push.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deploy Local | ${{ needs.deploy-local.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deploy Prod | ${{ needs.deploy-prod.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Post-Deploy Tests | ${{ needs.post-deployment-tests.result }} |" >> $GITHUB_STEP_SUMMARY